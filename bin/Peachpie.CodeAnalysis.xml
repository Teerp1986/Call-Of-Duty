<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Peachpie.CodeAnalysis</name>
    </assembly>
    <members>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPhpNumberAddr">
            <summary>
            Copies <c>PhpNumber</c> into a temp variable and loads its address.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPhpStringAddr">
            <summary>
            Copies <c>PhpString</c> into a temp variable and loads its address.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPhpValueAddr">
            <summary>
            Copies <c>PhpValue</c> into a temp variable and loads its address.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitStructAddr(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Copies a value type from the top of evaluation stack into a temporary variable and loads its address.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertIntToLong(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            In case there is <c>Int32</c> or <c>bool</c> on the top of evaluation stack,
            converts it to <c>Int64</c>.
            </summary>
            <param name="stack">New type on top of stack.</param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertStringToPhpNumber(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            In case there is <c>string</c> or <c>PhpString</c> on the top of evaluation stack,
            converts it to <c>PhpNumber</c>.
            </summary>
            <returns>New type on top of stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitExprConvertNumberToDouble(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            In case expression is of type <c>Int32</c> or <c>bool</c> or <c>PhpNumber</c>,
            converts it to <c>double</c> and leaves the result on evaluation stack. Otherwise
            just emits expression and leaves it on evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToString(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Emits conversion to <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToPhpString(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Emits conversion to <c>PhpString</c> (aka writable string).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToPhpArray(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Emits conversion to <c>PhpArray</c>.
            Anyting else than <c>NULL</c> and <c>array</c> causes an exception of type <see cref="T:System.InvalidCastException"/> in runtime.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitAsObject(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits conversion "as object" keeping a reference type on stack or <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_ToClr(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Values are unwrapped into a corresponding CLR type.
            </summary>
            <remarks>
            This is used when passing a value to a .NET method accepting parameters of type `object`.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToClass(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits conversion to an object of given type.
            </summary>
            <param name="from">Type of value on top of the evaluation stack.</param>
            <param name="fromHint">Hint in case of multitype value.</param>
            <param name="to">Target type.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToDateTime(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits conversion to <c>System.DateTime</c>.
            </summary>
            <param name="from">Value on stack to be converted.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvertToIntStringKey(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Converts the value on stack to <c>IntStringKey</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvert(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.ConversionKind,System.Boolean)">
            <summary>
            Emits expression and converts it to required type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitConvert(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.ConversionKind)">
            <summary>
            Emits conversion from one CLR type to another using PHP conventions.
            </summary>
            <param name="from">Type of value on top of evaluation stack.</param>
            <param name="fromHint">Type hint in case of a multityple type choices (like PhpValue or PhpNumber or PhpAlias).</param>
            <param name="to">Target CLR type.</param>
            <param name="conversion">Conversion semantic.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LocalScope.IL">
            <summary>
            Gets underlaying <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LocalScope.Parent">
            <summary>
            Gets parent scope. Can be <c>null</c> in case of a root scope.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._contextPlace">
            <summary>
            Place for loading a reference to <c>Pchp.Core.Context</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._localsPlaceOpt">
            <summary>
            Place referring array of locals variables.
            This is valid for global scope, local scope with unoptimized locals and generators.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._tmpLocalsPlace">
            <summary>
            Place referring array to temporal local variables.
            </summary>
            <remarks>
            Must not be null if method contains any synthesized temporal local variables as they need to be indirect.
            </remarks>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._localsInitialized">
            <summary>
            Are locals initilized externally.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ThisPlaceOpt">
            <summary>
            Place for loading a reference to <c>this</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.GeneratorStateMachineMethod">
            <summary>
            In case code generator emits body of a generator SM method,
            gets reference to synthesized method symbol with additional information.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.GeneratorStateLocal">
            <summary>
            Local variable containing the current state of state machine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyBlock">
            <summary>
            "finally" block to be branched in when returning from the routine.
            This finally block is not handled by CLR as it is emitted outside the TryCatchFinally scope.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyState.None">
            <summary>continue to NextBlock</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyState.Return">
            <summary>continue to next ExtraFinallyBlock, eventually EmitRet</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyState.Exception">
            <summary>rethrow exception (<see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExceptionToRethrowVariable"/>)</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyStateVariable">
            <summary>
            Temporary variable holding state of "finally" block handling. Value of <see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyState"/>.
            Variable created once only if <see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExtraFinallyBlock"/> is set.
            Type: <c>System.Int32</c>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExceptionToRethrowVariable">
            <summary>
            Temporary variable holding exception to be rethrown after "finally" block ends.
            Type: <c>System.Exception</c>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.FunctionArgsArray">
            <summary>
            Local variable with array of all routine's arguments.
            PhpValue[]
            Initialized once when <see cref="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.Flags"/> has <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.UsesArgs"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._emmittedTag">
            <summary>
            BoundBlock.Tag value indicating the block was emitted.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Builder">
            <summary>
            Gets underlaying <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Module">
            <summary>
            Module builder.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Routine">
            <summary>
            Gets the routine we are emitting.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.DebugRoutine">
            <summary>
            For debug purposes.
            Current routine being generated.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TypeRefContext">
            <summary>
            Type context of currently emitted expressions. Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsDebug">
            <summary>
            Whether to emit debug assertions.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPdbSequencePoints">
            <summary>
            Whether to emit sequence points (PDB).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.DeclaringCompilation">
            <summary>
            Gets a reference to compilation object.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.BoundTypeRefFactory">
            <summary>Gets <see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.BoundTypeRefFactory"/> instance.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Conversions">
            <summary>
            Gets conversions helper class.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.CoreTypes">
            <summary>
            Well known types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.CoreMethods">
            <summary>
            Well known methods.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Factory">
            <summary>
            Factory for dynamic and anonymous types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsGlobalScope">
            <summary>
            Whether the generator corresponds to a global scope.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsInTrait">
            <summary>
            Whether the code is generated inside method in a trait type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsInCachedArrayExpression">
            <summary>
            Gets or sets value determining <see cref="T:Pchp.CodeAnalysis.Semantics.BoundArrayEx"/> is being emitted.
            When set, array expression caching is disabled.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.CallerType">
            <summary>
            Type of the caller context (the class declaring current method) or null.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.#ctor(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Copy ctor with different routine content (and TypeRefContext).
            Used for emitting in a context of a different routine (parameter initializer).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Generate">
            <summary>
            Emits routines body.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Scope">
            <summary>
            Gets a reference to the current scope.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Generate(Pchp.CodeAnalysis.CodeGen.IGenerator)">
            <summary>
            Invokes <see cref="M:Pchp.CodeAnalysis.CodeGen.IGenerator.Generate(Pchp.CodeAnalysis.CodeGen.CodeGenerator)"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsGenerated(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Gets value indicating whether the given block was already emitted.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadContext">
            <summary>
            Emits <c>context</c> onto the evaluation stack.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ContextPlaceOpt">
            <summary>
            Gets <see cref="T:Pchp.CodeAnalysis.CodeGen.IPlace"/> of current <c>Context</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitCallerTypeHandle">
            <summary>
            Emits <c>RuntimeTypeHandle</c> of current class context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.RuntimeCallerTypePlace">
            <summary>
            In case current routine has a caller context provided in runtime,
            gets its <see cref="T:Pchp.CodeAnalysis.CodeGen.IPlace"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LocalsPlaceOpt">
            <summary>
            Gets place referring to array of unoptimized local variables.
            Always valid in context of global scope.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TemporalLocalsPlace">
            <summary>
            Gets place referring to compiler generated temporal variables.
            </summary>
            <remarks>
            Must not be null for methods that contain any synthesized variables.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.HasUnoptimizedLocals">
            <summary>
            Gets value indicating the routine uses unoptimized locals access.
            This means, all the local variables are stored within an associative array instead of local slots.
            This value implicates, <see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LocalsPlaceOpt"/> is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.InitializedLocals">
            <summary>
            Gets value indicating the routine has locals already inicialized. 
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitThis">
            <summary>
            Emits reference to <c>this</c>.
            </summary>
            <returns>Type of <c>this</c> in current context, pushed on top of the evaluation stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPhpThis">
            <summary>
            Emits value of <c>$this</c>.
            Available only within source routines.
            In case no $this is available, nothing is emitted and function returns <c>null</c> reference.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitPhpThisOrNull">
            <summary>
            Emits value of <c>$this</c>.
            Available only within source routines.
            In case no $this is available, <c>NULL</c> is loaded on stack instead.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TryEmitVariableSpecialize(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TryEmitVariableSpecialize(Pchp.CodeAnalysis.CodeGen.IPlace,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitSpecialize(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
            </summary>
            <returns>New type on top of evaluation stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitSpecialize(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
            </summary>
            <param name="stack">Type of value currently on top of evaluationb stack.</param>
            <param name="tmask">Result of analysis what type will be there in runtime.</param>
            <returns>New type on top of evaluation stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadToken(Pchp.CodeAnalysis.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Loads <see cref="T:System.RuntimeTypeHandle"/> of given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadToken(Pchp.CodeAnalysis.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Loads <see cref="T:System.RuntimeMethodHandle"/> of given method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLogicNegation">
            <summary>
            Emits "!= 0" operation. This method expects I4 value on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNotNull(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Emits check if type on top of the stack is null.
            Results in boolean (<c>i4</c>) with value of <c>0</c> or <c>1</c> on top of the stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitFieldAddress(Pchp.CodeAnalysis.Symbols.FieldSymbol)">
            <summary>
            Loads field address on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitSystemType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits <c>typeof(symbol) : System.Type</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadPhpTypeInfo(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            GetPhpTypeInfo&lt;T&gt;() : PhpTypeInfo
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadStaticPhpTypeInfo">
            <summary>
            Emits <c>PhpTypeInfo</c> of late static bound type.
            </summary>
            <returns>
            Type symbol of <c>PhpTypeInfo</c>.
            </returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadSelf(System.Boolean)">
            <summary>
            Loads <c>PhpTypeInfo</c> of <c>self</c>.
            </summary>
            <param name="throwOnError">Whether to expect only valid scope.</param>
            <returns>Type symbol of PhpTypeInfo.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadParent">
            <summary>
            Loads <c>PhpTypeInfo</c> of current scope's <c>parent</c> class;
            </summary>
            <returns>
            Type symbol of <c>PhpTypeInfo</c>.
            </returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpAlias_GetValue">
            <summary>
            Emits load of <c>PhpAlias.Value</c>,
            expecting <c>PhpAlias</c> on top of evaluation stack,
            pushing <c>PhpValue</c> on top of the stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpAlias_SetValue">
            <summary>
            Emits store to <c>PhpAlias.Value</c>,
            expecting <c>PhpAlias</c> and <c>PhpValue</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpValue_MakeAlias">
            <summary>
            Emits <c>new PhpAlias</c>, expecting <c>PhpValue</c> on top of the evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpValue_Void">
            <summary>
            Emits load of PhpValue representing void.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpValue_Null">
            <summary>
            Emits load of PhpValue representing null.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpValue_True">
            <summary>
            Emits load of PhpValue representing true.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpValue_False">
            <summary>
            Emits load of PhpValue representing false.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpArray_NewEmpty">
            <summary>
            Creates new empty <c>PhpArray</c> where modifications are not expected.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpArray_Empty">
            <summary>
            Emits LOAD of <c>PhpArray.Empty</c> fields.
            The loaded value must not be modified, use only in read-only context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_EmptyArray(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Template: <code>Array.Empty&lt;elementType&gt;()</code></summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_ArgsArray(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits array of <paramref name="elementType"/> containing all current routine PHP arguments value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_ArgumentsIntoArray(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Semantics.BoundArgument},Pchp.CodeAnalysis.Symbols.PhpSignatureMask)">
            <summary>
            Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
            Argument unpacking is taken into account and flatterned.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.UnpackArgumentsIntoArray(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Semantics.BoundArgument},Pchp.CodeAnalysis.Symbols.PhpSignatureMask)">
            <summary>
            Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
            Argument unpacking is taken into account and flatterned.
            </summary>
            <param name="args">Arguments to be flatterned into a single dimensional array.</param>
            <param name="byrefargs">Mask of arguments that must be passed by reference.</param>
            <remarks>The method assumes the arguments list contains a variable unpacking. Otherwise this method is not well performance optimized.</remarks>
            <returns>Type symbol corresponding to <c>PhpValue[]</c></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ArrayToPhpArray(Pchp.CodeAnalysis.CodeGen.IPlace,System.Boolean,System.Int32)">
            <summary>
            Builds <c>PhpArray</c> out from <c>System.Array</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ArrayToNewArray(Pchp.CodeAnalysis.CodeGen.IPlace,System.Int32,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Creates array from source array.
            </summary>
            <param name="srcarray">Source array.</param>
            <param name="srcfrom">First element to be copied.</param>
            <param name="targetArrElement">Target array element type.</param>
            <returns>Type of target array which is left on top of stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitEnumerateArray(Pchp.CodeAnalysis.CodeGen.IPlace,System.Int32,System.Action{Microsoft.CodeAnalysis.CodeGen.LocalDefinition,System.Func{Pchp.CodeAnalysis.Symbols.TypeSymbol}})">
            <summary>
            Emits for-loop of elements in given array provided through <paramref name="arrplace"/>.
            </summary>
            <param name="arrplace">Place representing source array.</param>
            <param name="startindex">First element index to enumerato from.</param>
            <param name="bodyemit">Action used to emit the body of the enumeration.
            Gets source element index and delegate that emits the LOAD of source element.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitArrayLength">
            <summary>
            Emits <c>Array.Length</c> call expecting an array instance on top of the stack, returning <c>int</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitCall(System.Reflection.Metadata.ILOpCode,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Emits call to given method.
            </summary>
            <param name="code">Call op code, Call, Callvirt, Calli.</param>
            <param name="method">Method reference.</param>
            <returns>Method return type.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LoadTargetInstance(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Emits <paramref name="thisExpr"/> to be used as target instance of method call, field or property.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadCurrentClassContext(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Loads "self" class onto the stack.
            </summary>
            <param name="astype">Type to be used to represent "self" - PhpTypeInfo, string, RuntimeTypeHandle.</param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitCall_UnpackingArgs(System.Reflection.Metadata.ILOpCode,Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Semantics.BoundArgument},Pchp.CodeAnalysis.Semantics.BoundTypeRef)">
            <summary>
            Emits known method call if arguments have to be unpacked before the call.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitForwardCall(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.CodeGen.IPlace,System.Boolean)">
            <summary>
            Emits .call to <paramref name="target"/> with the same arguments the caller method parameters (<paramref name="thismethod"/>) including reference to <c>this</c>.
            </summary>
            <param name="target">Method to be called.</param>
            <param name="thismethod">Current method.</param>
            <param name="thisPlaceExplicit">Optionaly specified place of object instance to call the method on.</param>
            <param name="callvirt">Whether to call the method virtually through <c>.callvirt</c>.</param>
            <returns>Return of <paramref name="target"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitMethodAccess(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Emits necessary conversion and copying of value returned from a method call.
            </summary>
            <param name="stack">Result value type on stack.</param>
            <param name="method">Called method. Can be <c>null</c> for indirect method calls.</param>
            <param name="access">Expression access.</param>
            <returns>New type on stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitCastToFalse(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Converts <b>negative</b> number or <c>null</c> to <c>FALSE</c>.
            </summary>
            <param name="stack">Type of value on stack.</param>
            <param name="targetType">Optional hint, the expected conversion of the resulting value.</param>
            <returns>New type of value on stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNullableCastToNull(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Converts <b>Nullable</b> without a value to <c>NULL</c>.
            </summary>
            <param name="stack">Type of Nullable&lt;T&gt; value on stack.</param>
            <param name="deepcopy">Whether to deep copy returned non-FALSE value.</param>
            <returns>New type of value on stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNullableCoalescing(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Func{Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol},System.Func{Pchp.CodeAnalysis.Symbols.TypeSymbol})">
            <summary>
            Emits code that converts Nullable. Expects Nullable{T} on stack:
            {stack}.HasValue ? {stack}.GetValueOrDefault() : default
            </summary>
            <param name="stack">Type of Nullable&lt;T&gt; value on stack.</param>
            <param name="valueEmitter">Delegate to emit a conversion from &lt;T&gt;. &lt;T&gt; is on the stack.</param>
            <param name="novalueEmitter">Delegate to emit a value if the Nullable has no value. If no provided, a default of {T} is put on the stack.</param>
            <returns>New type of value on stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNullCoalescing(System.Action{Pchp.CodeAnalysis.CodeGen.CodeGenerator})">
            <summary>
            Emits <c>??</c> operation against the value on top of the evaluation stack.
            </summary>
            <param name="nullemitter">Routine that emits the FALSE branch of the operator.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNullCoalescing(System.Action,System.Action)">
            <summary>
            Emits <c>?:</c> operation against the value on top of the evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitInitializePlace(Pchp.CodeAnalysis.CodeGen.IPlace)">
            <summary>
            Initializes place with a default value.
            This applies to structs without default ctor that won't work properly when uninitialized.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo">
            <summary>
            Temporary data used to call routines that expect ref or out parameters when given variable can't be passed by ref.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.TmpLocal">
            <summary>
            The temporary local passed by reference to a function call.
            After the call, it's value has to be written back to <see cref="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.Target"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.Target">
            <summary>
            Original variable passed to the function call.
            Target of the write-back routine.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.CreateAndLoad(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.ParameterSymbol,Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            Loads temporary local variable as an argument to <paramref name="targetp"/>.
            </summary>
            <param name="cg"></param>
            <param name="targetp">Target parameter.</param>
            <param name="expr">Value to be passed as its argument.</param>
            <returns><see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo"/> which has to be finalized with <see cref="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.WriteBackAndFree(Pchp.CodeAnalysis.CodeGen.CodeGenerator)"/> once the routine call ends.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.WriteBackAndFree(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Writes the value back to <see cref="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo.Target"/> and free resources.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.DetermineClrSemantic(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determine whether the argument load complies with CLR semantic rather than PHP semantic.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.DetermineStrictSemantic(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determine the argument load complies with PHP strict semantic.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadArgument(Pchp.CodeAnalysis.Symbols.ParameterSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Collections.Generic.List{Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo})">
            <summary>
            Loads argument from bound expression.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadArgument(Pchp.CodeAnalysis.Symbols.ParameterSymbol,Pchp.CodeAnalysis.CodeGen.IPlace,System.Int32,System.Collections.Generic.List{Pchp.CodeAnalysis.CodeGen.CodeGenerator.WriteBackInfo})">
            <summary>
            Loads argument from arguments array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitParameterDefaultValue(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Emits default value of given parameter.
            Puts value of target parameter's type.
            </summary>
            <param name="targetp">Parameter to emit its default value.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpStringBlob_Append(Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean)">
            <summary>
            Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> on top of evaluation stack.
            </summary>
            <param name="value">The expression to be appended.</param>
            <param name="expandConcat">Whether to skip evaluation of <c>concat</c> expression and directly append its arguments.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.Emit_PhpStringBlob_Append(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> and <paramref name="ytype"/> on top of evaluation stack.
            </summary>
            <param name="ytype">Type of argument loaded on stack.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitEcho(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Emits <c>echo</c> statement of the type on stack.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitWithDisabledErrorReporting(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Emits the expression decorated with error reporting disabling routine.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDeclareFunction(Pchp.CodeAnalysis.Symbols.SourceFunctionSymbol)">
            <summary>
            Emits declaring function into the context.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.CodeGenerator._staticallyDeclaredTypes">
            <summary>
            Set of types which declaration was already emitted at the beginning of script.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDeclareTypesInParsePhase(System.Collections.Generic.IEnumerable{Pchp.CodeAnalysis.Symbols.SourceTypeSymbol})">
            <summary>
            Emits declaration of types that can be declared at the beginning of script.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDeclareType(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol,System.Boolean)">
            <summary>
            Emits type declaration into the context.
            </summary>
            <param name="t">Type to be declared.</param>
            <param name="parsePhase"><c>true</c> in case we're just trying to declare the type; it won't cause any autoload, it won't cause any runtime exception.</param>
            <returns>Value indicating the type got declared unconditionally.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsTypeDeclaredCheckNecessary(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Gets value indicating runtime check for given type existance may be necessary.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitExpectTypeDeclared(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            If necessary, emits autoload and check the given type is loaded into context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitVersionedTypeDeclaration(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.SourceTypeSymbol})">
            <summary>
            Emit declaration of one of given versions (of the same source type) based on actually declared types that versions depend on.
            </summary>
            <param name="versions">Array of multiple versions of a source type declaration.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDeclareTypeByDependencies(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.SourceTypeSymbol},System.Collections.Generic.KeyValuePair{Devsense.PHP.Syntax.QualifiedName,Microsoft.CodeAnalysis.CodeGen.LocalDefinition}[],System.Int32,System.Collections.Generic.Dictionary{Devsense.PHP.Syntax.QualifiedName,System.Collections.Generic.HashSet{Pchp.CodeAnalysis.Symbols.NamedTypeSymbol}},Pchp.CodeAnalysis.CodeGen.NamedLabel,Pchp.CodeAnalysis.CodeGen.NamedLabel)">
            <summary>
            Emits decision tree.
            </summary>
            <param name="versions">Versions to decide of.</param>
            <param name="dependency_handle">Map of dependant types and associated local variable holding resolved real type handle.</param>
            <param name="index">Index to <paramref name="dependency_handle"/> where to decide from.</param>
            <param name="dependencies">Map of type names and possible real types.</param>
            <param name="lblDone">Label where to jump upon decision is done.</param>
            <param name="lblFail">Label where to jump when dependy does not match.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitThrowException(System.String)">
            <summary>
            Emits <code>throw new Exception(message)</code>
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitCallMain(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Emits call to main method.
            </summary>
            <param name="mainmethod">Static Main method representing the script global code.</param>
            <returns>Main method result value type.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitLoadDefaultOfValueType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits <c>default(valuetype)</c>.
            Handles special types with a default ctor.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitRet(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Emits .ret instruction with sequence point at closing brace.
            Eventually emits branching to closing block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitNotNull(Pchp.CodeAnalysis.CodeGen.IPlace)">
            <summary>
            Emits <c>place != null</c> expression.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDebugAssertNotNull(Pchp.CodeAnalysis.CodeGen.IPlace,System.String)">
            <summary>
            Emits <c>Debug.Assert([<paramref name="place"/>]) in debug compile mode.</c>
            </summary>
            <param name="place">The variable to emit assertion for.</param>
            <param name="messageOpt">Optional second argument for assert.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDebugAssert(System.String)">
            <summary>
            Emits <c>Debug.Assert([stack]).</c>
            </summary>
            <param name="messageOpt">Optional second argument for assert.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.EmitDeepCopy(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Emits copy of value from top of the stack if necessary.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.GetTemporaryLocal(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.CodeGen.LocalDefinition"/> of a temporary local variable of a specified <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/>.
            </summary>
            <param name="type">The requested <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/> of the local.</param>
            <param name="immediateReturn"><c>True</c> to immediately return the local builder to the pool of locals
            available for reuse (no need to call <see cref="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ReturnTemporaryLocal(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)"/>).</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.CodeGen.LocalDefinition"/>.</returns>
            <remarks>
            If a <see cref="T:Microsoft.CodeAnalysis.CodeGen.LocalDefinition"/> of the given <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/> has already been declared and returned
            to the pool, this local is reused. Otherwise, a new local is declared. Use this method to obtain a
            short-lived temporary local. If <paramref name="immediateReturn"/> is <c>false</c>, return the local
            to the pool of locals available for reuse by calling <see cref="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ReturnTemporaryLocal(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)"/>.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ReturnTemporaryLocal(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.CodeGen.LocalDefinition"/> previously obtained from <see cref="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.GetTemporaryLocal(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)"/> to the
            pool of locals available for reuse.
            </summary>
            <param name="definition">The <see cref="T:Microsoft.CodeAnalysis.CodeGen.LocalDefinition"/> to return to the pool.</param>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TemporaryLocalDefinition">
            <summary>
            Definition of a temporary local variable.
            The variable can be a local variable or a special temporary local variable living in array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.TemporaryLocalDefinition.EmitStore">
            <summary>
            Stores the value from top of the stack into this temporary local variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.GetTemporaryLocal(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Returns a temporary local variable of a specified <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/>.
            </summary>
            <param name="type">Type of the variable.</param>
            <param name="longlive">Whether the variable has to be retained out of current statement. In some cases, this causes the temporary variable not being represented as local on stack.</param>
            <param name="immediateReturn">Whether the temporary variable is released immediatelly.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.PlaceOrNull(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            If possible, gets <see cref="T:Pchp.CodeAnalysis.CodeGen.IPlace"/> representing given expression (in case of a field or variable).
            </summary>
            <param name="expr"></param>
            <returns>Place or <c>null</c>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsDoubleOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents a double and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsLongOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents a long and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsNumberOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>The given type represents only an integer, long or double.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsBooleanOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents a boolean and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsReadonlyStringOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents UTF16 readonly string and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsClassOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents only class types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsArrayOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents only PHP Array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.CanBeNull(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the type can be <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.CanBeNull(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets value indicating the type can hold <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsCopiable(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Determines whether the type needs to be copied when passing by value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.CodeGenerator.IsCopiable(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Determines whether the type needs to be copied when passing by value.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.IGenerator">
            <summary>
            Represents a semantic element that can be emitted.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.IGenerator.Generate(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits IL into the underlaying <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ILBuilderExtension.EmitValueDefaultAddr(Microsoft.CodeAnalysis.CodeGen.ILBuilder,Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Gets addr of a default value. Used to call a method on default value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ILBuilderExtension.GetTemporaryLocalAndReturn(Microsoft.CodeAnalysis.CodeGen.ILBuilder,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets or create a local variable and returns it back to pool.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ILBuilderExtension.EmitStructAddr(Microsoft.CodeAnalysis.CodeGen.ILBuilder,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Copies a value type from the top of evaluation stack into a temporary variable and loads its address.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ILBuilderExtension.EmitCall(Microsoft.CodeAnalysis.CodeGen.ILBuilder,Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag,System.Reflection.Metadata.ILOpCode,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Emits call to given method.
            </summary>
            <returns>Method return type.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ConversionsExtensions.TryEmitImplicitConversion(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Resolves the conversion operator and emits the conversion, expecting <paramref name="from"/> on STACK.
            </summary>
            <param name="cg">Code generator.</param>
            <param name="from">Type on stack.</param>
            <param name="to">Type that will be on stack after the successful operation.</param>
            <param name="checked">Whether the numeric conversion is checked.</param>
            <param name="strict"><c>True</c> to emit strict conversion if possible.</param>
            <returns>Whether operation was emitted.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.ConversionsExtensions.EmitConversion(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Microsoft.CodeAnalysis.Operations.CommonConversion,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Emits the given conversion. 'from' and 'to' matches the classified conversion.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.Target">
            <summary>
            CallSite_T.Target method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.Place">
            <summary>
            CallSite_T field.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.CallSite_Create">
            <summary>
            Gets CallSite.Create method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.Arguments">
            <summary>
            Gets emitted callsite arguments.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData._cg">
            <summary><see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator"/> instance.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.AddArg(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Notes arguments pushed on the stack to be passed to callsite.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitArgs(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Semantics.BoundArgument})">
            <summary>Emits arguments to be passed to callsite.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitArg(Pchp.CodeAnalysis.Semantics.BoundArgument)">
            <summary>Emits argument to be passed to callsite.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement">
            <summary>
            Helper class describing an element of <c>Core.Dynamic.IRuntimeChain</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement.Type">
            <summary>Chain runtime element.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement.Parent">
            <summary>Chain's member of.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement.Fields">
            <summary>Optional properties of the chain element.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement.Next">
            <summary>Chain's next element.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.RuntimeChainElement.EmitRuntimeChain(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emit runtime chain.
            </summary>
            <returns>Runtime chain value type pushed on top of the stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitWrapParam(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>Emits new instance of wrapper with value. Returns wrapper.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitLoadContext">
            <summary>Template: &lt;ctx&gt;</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitCallerTypeParam">
            <summary>
            If needed in runtime, emits caller type context.
            Template: new CallerTypeParam(RuntimeTypeHandle)</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitTargetTypeParam(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>Template: new TargetTypeParam(PhpTypeInfo)</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitLateStaticTypeParam(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>Template: new LateStaticTypeParam(PhpTypeInfo)</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitNameParam(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>Template: new NameParam{T}(STACK)</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitNameParam(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Template: new NameParam{T}(STACK)</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CallSiteData.EmitUnpackingParam(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Template: new UnpackingParam{T}(STACK)</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CctorBuilder">
            <summary>
            Static constructor IL builder for dynamic sites in current context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.DynamicOperationFactory.CreateSynthesizedField(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.String,System.Boolean)">
            <summary>
            Creates internal autoincremented field in current container.
            </summary>
            <param name="type">Field type.</param>
            <param name="name">Field name prefix.</param>
            <param name="isstatic">Whether the field is static.</param>
            <returns>The synthesized field.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.GhostMethodBuilder.CreateGhostOverload(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.ParameterSymbol},System.Boolean,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Creates ghost stub that calls method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.GhostMethodBuilder.GenerateGhostBody(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag,Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.SynthesizedMethodSymbol)">
            <summary>
            Generates ghost method body that calls <c>this</c> method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.MethodGenerator.GenerateMethodBody(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Pchp.CodeAnalysis.Symbols.MethodSymbol,System.Action{Microsoft.CodeAnalysis.CodeGen.ILBuilder},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Generates method body that calls another method.
            Used for wrapping a method call into a method, e.g. an entry point.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.IPlace">
            <summary>
            Lightweight abstraction over a native storage supported by storage places with address.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.IPlace.Type">
            <summary>
            Gets the type of place.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.IPlace.EmitLoad(Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Emits code that loads the value from this storage place.
            </summary>
            <param name="il">The <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/> to emit the code to.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.IPlace.EmitStorePrepare(Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Emits preparation code for storing a value into the place.
            Must be call before loading a value and calling <see cref="M:Pchp.CodeAnalysis.CodeGen.IPlace.EmitStore(Microsoft.CodeAnalysis.CodeGen.ILBuilder)"/>.
            </summary>
            <param name="il">The <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/> to emit the code to.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.IPlace.EmitStore(Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Emits code that stores a value to this storage place.
            </summary>
            <param name="il">The <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/> to emit the code to.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.CodeGen.IPlace.EmitLoadAddress(Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Emits code that loads address of this storage place.
            </summary>
            <param name="il">The <see cref="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder"/> to emit the code to.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.CodeGen.IPlace.HasAddress">
            <summary>
            Gets whether the place has an address.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.ReadOnlyPlace">
            <summary>
            Place wrapper allowing only read operation.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CodeGen.FieldPlace_Raw">
            <summary>
            When we handle emitting receiver by ourselves.
            Emits op codes for using <see cref="T:Pchp.CodeAnalysis.Symbols.FieldSymbol"/> but does not emit load of receiver.
            Use <see cref="T:Pchp.CodeAnalysis.CodeGen.FieldPlace"/> instead.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock">
            <summary>
            Represents control flow block.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.EmitOrderComparer">
            <summary>
            Helper comparer defining order in which are blocks emitted if there is more than one in the queue.
            Can be used for optimizing branches heuristically.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.FlowState">
            <summary>
            Initial block flow state.
            Can be <c>null</c> in case there is no flow into the block, the state was released, or
            doesn't match the current version of the analysis.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.OrdinalComparer">
            <summary>
            Comparer to sort the blocks in the ascending order of <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.Ordinal"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.DebugName">
            <summary>
            Internal name of the block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.DebugDisplay">
            <summary>
            Debugger display.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.Tag">
            <summary>
            Tag used for graph algorithms.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.Statements">
            <summary>
            Gets statements contained in this block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.NextEdge">
            <summary>
            Gets edge pointing out of this block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.Ordinal">
            <summary>
            Gets block topological index.
            Index is unique within the graph.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.IsDead">
            <summary>
            Gets value indicating the block is unreachable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.Add(Pchp.CodeAnalysis.Semantics.BoundStatement)">
            <summary>
            Adds statement to the block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.BoundBlock.SkipEmpty(System.Collections.Generic.IEnumerable{Pchp.CodeAnalysis.Semantics.Graph.BoundBlock})">
            <summary>
            Traverses empty blocks to their non-empty successor. Skips duplicities.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.StartBlock">
            <summary>
            Represents a start block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.StartBlock.EmitIndirectLocalsDebugWatch(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            For debugger purposes; emits dummy variable that shows value of indirect locals.
            Using these dummy locals, user can see variables in Watch or Locals window even all the variables are stored indirectly in <see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.LocalsPlaceOpt"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.StartBlock.DebugName">
            <summary>
            Internal name of the block.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock">
            <summary>
            Represents an exit block.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock._rettmp">
            <summary>
            Temporary local variable for return.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock._retlbl">
            <summary>
            Return label.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock._throwlbl">
            <summary>
            Rethrow label.
            Marks code that rethrows <see cref="P:Pchp.CodeAnalysis.CodeGen.CodeGenerator.ExceptionToRethrowVariable"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock.EmitTmpRet(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Stores value from top of the evaluation stack to a temporary variable which will be returned from the exit block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock.EmitGeneratorEnd(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            set generator state to -2 (closed)
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock.Subscribe(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Subscribe a block to be analysed when the exit block is reached and the routine return value changes.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock._subscribers">
            <summary>
            Set of blocks making call to this routine (callers) (may be from another CFG) waiting for return type of this routine.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock._lastReturnTypeMask">
            <summary>
            Return type last seen by subscribers.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ExitBlock.DebugName">
            <summary>
            Internal name of the block.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.Edge">
            <summary>
            Represents an edge to other blocks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.Edge.Generate(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Generates or enqueues next blocks to the worklist.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.PhpSyntax">
            <summary>
            Associated syntax node.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.Targets">
            <summary>
            Target blocks.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.NextBlock">
            <summary>
            The block after the edge. Can be a <c>null</c> reference.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.IsConditional">
            <summary>
            Gets value indicating whether the edge represents a conditional edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.IsTryCatch">
            <summary>
            Gets value indicating whether the edge represents try/catch.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.IsSwitch">
            <summary>
            Gets value indicating whether the edge represents switch.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.Condition">
            <summary>
            Condition expression of conditional edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.CatchBlocks">
            <summary>
            Catch blocks if try/catch edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.FinallyBlock">
            <summary>
            Finally block of try/catch edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.Edge.CaseBlocks">
            <summary>
            Enumeration with single case blocks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.Edge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.SimpleEdge">
            <summary>
            Represents simple unconditional jump.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.SimpleEdge.Target">
            <summary>
            Target block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.SimpleEdge.NextBlock">
            <summary>
            Gets the target block if the simple edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.SimpleEdge.Targets">
            <summary>
            Target blocks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.SimpleEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.LeaveEdge">
            <summary>
            Represents an edge leaving try/catch block.
            The edge is not emitted.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge">
            <summary>
            Conditional edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge.IsLoop">
            <summary>
            Gets a value indicating the condition within a loop construct.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge.TrueTarget">
            <summary>
            Target true block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge.FalseTarget">
            <summary>
            Target false block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge.Targets">
            <summary>
            All target blocks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ConditionalEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge">
            <summary>
            Represents try/catch/finally edge.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.EmitCatchFinallyOutsideScope">
            <summary>
            Whether to emit catch and finally bodies outside the TryCatchFinally scope.
            This allows to branch inside catch or finally from outside,
            or branch outside of try without calling finally (required for yield and return functionality).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.NextBlock">
            <summary>
            Where <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.BodyBlock"/>, catch blocks and <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.FinallyBlock"/> go to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.BodyBlock">
            <summary>
            Try block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.Targets">
            <summary>
            All target blocks.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.TryBlockScopeEnd">
            <summary>
            Ordinal of the block after the <c>try</c> scope.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.TryCatchEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ForeachEnumereeEdge">
            <summary>
            Represents foreach edge through the enumeree invocation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachEnumereeEdge.Enumeree">
            <summary>
            Array to enumerate through.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ForeachEnumereeEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge">
            <summary>
            Represents foreach edge from enumeree invocation through <c>MoveNext</c> to body block or end.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.MoveNextSpan">
            <summary>
            Span of the move expression to emit sequence point of <c>MoveNext</c> operation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.BodyBlock">
            <summary>
            Content of the foreach.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.NextBlock">
            <summary>
            Block after the foreach.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.EnumereeEdge">
            <summary>
            Reference to the edge defining the enumeree.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.KeyVariable">
            <summary>
            Variable to store key in (can be null).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.ValueVariable">
            <summary>
            Variable to store value in
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ForeachMoveNextEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.SwitchEdge">
            <summary>
            Represents switch edge.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.SwitchEdge.GetSwitchCaseLabels(System.Collections.Generic.IEnumerable{Pchp.CodeAnalysis.Semantics.Graph.CaseBlock})">
            <summary>
            Gets case labels.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.SwitchEdge.SwitchValue">
            <summary>
            The expression representing the switch value.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.SwitchEdge.DefaultBlock">
            <summary>
            Gets the case blocks representing a default section.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.SwitchEdge.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits the object by given visitor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph">
            <summary>
            Represents statements control flow graph.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.FlowContext">
            <summary>
            Gets flow analysis context for this CFG.
            </summary>
            <remarks>CFG has to be analysed prior to getting this property.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.GetLocalTypeMask(System.String)">
            <summary>
            Gets possible types of a local variable.
            </summary>
            <remarks>CFG has to be analysed prior to getting this property.</remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockFlags">
            <summary>
            Found label reference (definition or target) information.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockFlags.None">
            <summary>
            Not used nor defined.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockFlags.Defined">
            <summary>
            Label is defined.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockFlags.Used">
            <summary>
            Label is used as a target.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockFlags.Redefined">
            <summary>
            Label was defined twice or more.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockState">
            <summary>
            Label state.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockState.Label">
            <summary>
            Label identifier.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockState.LabelSpan">
            <summary>
            Positions of label definition and/or last label use.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockState.TargetBlock">
            <summary>
            Lable target block.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.LabelBlockState.Flags">
            <summary>
            Label information.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.Start">
            <summary>
            Gets the control flow start block. Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.Exit">
            <summary>
            Gets the control flow exit block. Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.Labels">
            <summary>
            Array of labels within routine. Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.Yields">
            <summary>
            Array of yield statements within routine. Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.UnreachableBlocks">
            <summary>
            List of blocks that are unreachable syntactically (statements after JumpStmt etc.).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph._lastcolor">
            <summary>
            Last "tag" color used. Used internally for graph algorithms.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.NewColor">
            <summary>
            Gets new (unique) color for use by graph algorithms.
            </summary>
            <returns>New color index.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph.Accept``1(Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor{``0})">
            <summary>
            Visits control flow blocks and contained statements, in deep.
            Unreachable blocks are not visited.
            </summary>
            <remarks>Visitor does not implement infinite recursion prevention.</remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.CatchBlock">
            <summary>
            Represents control flow block of catch item.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CatchBlock.DebugName">
            <summary>
            Internal name of the block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CatchBlock.TypeRef">
            <summary>
            Catch variable type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CatchBlock.Variable">
            <summary>
            A variable where an exception is assigned in.
            Can be <c>null</c> if catch is non-capturing.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.CaseBlock">
            <summary>
            Represents control flow block of case item.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CaseBlock.DebugName">
            <summary>
            Internal name of the block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CaseBlock.CaseValue">
            <summary>
            Gets case value expression bag.
            In case of default case, it is set <see cref="P:Pchp.CodeAnalysis.Semantics.BoundItemsBag`1.Empty"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.CaseBlock.IsDefault">
            <summary>
            Gets value indicating whether the case represents a default.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor">
            <summary>
            Visitor implementation that constructs the graph.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor._returnCounter">
            <summary>Counts visited "return" statements.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.Declarations">
            <summary>
            Gets enumeration of unconditional declarations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.Labels">
            <summary>
            Gets labels defined within the routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.DeadBlocks">
            <summary>
            Blocks we know nothing is pointing to (right after jump, throw, etc.).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.BreakTargetScope">
            <summary>
            Represents break scope.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.NewDeadBlock">
            <summary>
            Creates block we know nothing is pointing to.
            Such block will be analysed later whether it is empty or whether it contains some statements (which will be reported as unreachable).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.BuilderVisitor.NewOrdinal">
            <summary>
            Gets new block index.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1">
            <summary>
            Visitor used to traverse CFG and all its operations with infinite recursion prevention.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1.#ctor(System.Nullable{System.Int32})">
            <summary>
            Create a new instance of <see cref="T:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1"/>, optionally specifying a custom
            color for exploration.
            </summary>
            <param name="exploredColor">Custom color to be used for exploration, specify if
            <see cref="M:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1.VisitCFG(Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph)"/> is not going to be used.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1.VisitCFG(Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph)">
            <summary>
            Set <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.GraphExplorer`1.ExploredColor"/> to a new color from <paramref name="x"/> and perform
            the exploration.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter">
            <summary>
            Enables to transform a <see cref="T:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph"/> in a straightforward manner.
            </summary>
            <remarks>
            The transformation is performed in two phases: updating and repairing. During updating,
            virtual Visit* and OnVisit* methods are called on all the nodes, edges and operations
            in the CFG. <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.ExploredColor"/> is used in the update to mark all the visited
            nodes and prevent infinite recursion. Any update of the graph marks all the changed nodes
            (their new versions) as <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.ChangedColor"/>. If such an update happens, in the
            repairing phase the whole graph is traversed again and all the unmodified blocks are cloned,
            the edges fixed and all the blocks in the final graph marked as <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.RepairedColor"/>.
            
            This is done to prevent the graph nodes from pointing to nodes of the older version of the
            graph. Possible optimization would be to allow sharing graph parts in acyclic CFGs.
            </remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.GraphRepairer">
            <summary>
            Clones unmodified blocks and fixes the edges between them so that no edge targets
            a block from the previous version of the graph.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.UnreachableProcessor">
            <summary>
            Finds all yield statements in unreachable blocks (those not yet colored by <see cref="P:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.ExploredColor"/>)
            of the original graph. Marks all declarations as unreachable. The blocks encountered along the way are
            coloured as a side effect.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter.NotePossiblyUnreachable(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Inform about a possible unreachability of this block due to a change in the graph.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphUpdater">
            <summary>
            Helper class for <see cref="T:Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph"/> update. Calls Update on each block, edge, statement
            and expression in a CFG (but <see cref="M:Pchp.CodeAnalysis.Semantics.Graph.GraphUpdater.VisitCFG(Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph)"/> not supported).
            Doesn't contain any infinite recursion protection.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphUpdater.VisitCFG(Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph)">
            <summary>
            Not supported, use <see cref="T:Pchp.CodeAnalysis.Semantics.Graph.GraphRewriter"/> instead.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Graph.GraphUpdater.IsConditional">
            <summary>
            Gets value indicating the current block is in a conditional scope.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor`1">
            <summary>
            Base visitor for control flow graphs.
            </summary>
            <typeparam name="TResult">Return type of all the Visit operations, use <see cref="T:Peachpie.CodeAnalysis.Utilities.VoidStruct"/> if none.</typeparam>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor`1.Accept(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>Visits given block.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphVisitor`1.Accept(Pchp.CodeAnalysis.Semantics.Graph.Edge)">
            <summary>Visits given edge.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.Graph.GraphWalker`1">
            <summary>
            Visitor used to traverse CFG and all its operations.
            </summary>
            <remarks>Visitor does not implement infinite recursion prevention.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Graph.GraphWalker`1.DefaultVisitBlock(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Visits block statements and its edge to next block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundExpression.Emit(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits the expression with its bound access.
            Only Read or None access is possible. Write access has to be handled separately.
            </summary>
            <param name="cg">Associated code generator.</param>
            <returns>The type of expression emitted on top of the evaluation stack.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.TypeRefMask">
            <summary>
            The type analysis result.
            Gets possible combination of the value type after evaluation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.Access">
            <summary>
            Additional expression access,
            specifies how the expression is being accessed.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.BoundConversion">
            <summary>
            Lazily resolved conversion used to access the value.
            Emitted and the result always implicitly converted to <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.Type"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ResultType">
            <summary>
            Lazily resolved type of the expression,
            after applying the <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.Access"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.Type">
            <summary>
            Lazily resolved type of the expression result.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.RequiresContext">
            <summary>
            Whether the expression needs current <c>Pchp.Core.Context</c> to be evaluated.
            Otherwise, the expression can be evaluated in app context or in compile time.
            </summary>
            <remarks>
            E.g. If the expression is a literal, a resolved constant or immutable, it does not require the Context.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.IsDeeplyCopied">
            <summary>
            Decides whether an expression represented by this operation should be copied if it is passed by value (assignment, return).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ConstantValue">
            <summary>
            Resolved value of the expression.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitAdd(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits <c>+</c> operator suitable for actual operands.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitAdd(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits <c>+</c> operator suitable for actual operands.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitSub(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits subtraction operator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitSub(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits subtraction operator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitCoalesce(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>Emits <c>??</c> operator and returns the result type.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitSpaceship(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>Emits the spaceship `&lt;=&gt;` operation.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitBinaryBooleanOperation(Pchp.CodeAnalysis.CodeGen.CodeGenerator,System.Boolean)">
            <summary>
            Emits binary boolean operation (AND or OR).
            </summary>
            <param name="cg">A code generator.</param>
            <param name="isAnd">Whether to emit AND, otherwise OR.</param>
            <returns>A type code of the result.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitBinaryXor(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits binary operation XOR.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitEquality(Pchp.CodeAnalysis.CodeGen.CodeGenerator,System.Boolean@)">
            <summary>
            Emits check for values equality.
            Lefts <c>bool</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitEquality(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Emits check for values equality.
            Lefts <c>bool</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitEquality(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean@)">
            <summary>
            Emits check for values equality.
            Lefts <c>bool</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitEquality(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean@)">
            <summary>
            Emits check for values equality.
            Lefts <c>bool</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitLtGt(Pchp.CodeAnalysis.CodeGen.CodeGenerator,System.Boolean)">
            <summary>
            Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
            </summary>
            <param name="cg">Code generator helper.</param>
            <param name="lt">True for <c>clt</c> (less than) otherwise <c>cgt</c> (greater than).</param>
            <returns>Resulting type code pushed onto the top of evaliuation stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitLtGt(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean)">
            <summary>
            Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
            </summary>
            <returns>Resulting type code pushed onto the top of evaluation stack.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitMultiply(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits <c>*</c> operation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitDivision(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits <c>/</c> operator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.EmitPow(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits <c>pow</c> operator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundBinaryEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundUnaryEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundConversionEx">
            <summary>
            Explicit conversion operation (cast operation).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundCallableConvert">
            <summary>
            Conversion to <c>IPhpCallable</c> (callable).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundCallableConvert.TargetCallable">
            <summary>
            Resolved method to be converted to callable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundCallableConvert.Receiver">
            <summary>In case of an instance method, this is its receiver instance.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundLiteral.ResolveTypeMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Gets type mask of the literal within given type context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundLiteral.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue">
            <summary>
            Deeply copies the expression's dereferenced value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundReferenceExpression.BindPlace(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Gets <see cref="T:Pchp.CodeAnalysis.Semantics.IVariableReference"/> providing load and store operations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundReferenceExpression.MaybeUninitialized">
            <summary>
            Gets or sets value indicating the variable is used while it was not initialized in all code paths.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundVariableName">
            <summary>
            Direct or indirect variable name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundVariableName.EmitVariableName(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits the name of variable leaving <c>string</c> on top of evaluation stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundVariableName.Emit(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits the name expression as either <c>IntStringKey</c>, <c>String</c>, or <c>Int64</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundVariableRef">
            <summary>
            A variable reference that can be read or written to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariableRef.Name">
            <summary>
            Name of the variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariableRef.Variable">
            <summary>
            Resolved variable source.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariableRef.BeforeTypeRef">
            <summary>
            The type of variable before it gets accessed by this expression.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariableRef.Microsoft#CodeAnalysis#Operations#ILocalReferenceOperation#Local">
            <summary>
            Local in case of the variable is resolved local variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundVariableRef.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundListEx">
            <summary>
            PHP <c>list</c> expression that can be written to.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundListEx.EmitListAccess(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Emits conversion to <c>IPhpArray</c>.
            Emits empty array on top of stack if object cannot be used as array.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundListEx.Items">
            <summary>
            Bound target variables.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundListEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundFieldRef.Instance">
            <summary>
            In case of a non static field, gets its instance expression.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundFieldRef.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundRoutineCall">
            <summary>
            Represents a function call.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.EmitDynamicCall(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits the routine call in case the method symbol couldn't be resolved or it cannot be called directly.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.IsClrMagicCall(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Determines if the target magic method will be called using standard calling convention.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.LateStaticTypeRef">
            <summary>Type reference to the static type. The containing type of called routine, e.g. <c>THE_TYPE::foo()</c>. Used for direct method call requiring late static type..</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.EmitTarget(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Optional. Emits instance on which the method is invoked.
            In case of instance function call, it is the instance expression,
            in case of static method, it is reference to <c>$this</c> which may be needed in some cases.
            </summary>
            <returns>Type left on stack. Can be <c>null</c> if callsite does not expect a target.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.EmitTypeArgumentsArray(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits <c>System.Type[]</c> of type arguments.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.Instance">
            <summary>
            <c>this</c> argument to be supplied to the method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.TargetMethod">
            <summary>
            Resolved method if possible.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.HasArgumentsUnpacking">
            <summary>
            Gets value indicating the arguments has to be unpacked in runtime before passed to the function.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundGlobalFunctionCall.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundInstanceFunctionCall.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundStaticFunctionCall.EmitTarget(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits current class instance, expected by callsite to resolve instance function called statically.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundStaticFunctionCall.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundNewEx">
            <summary>
            Direct new expression with a constructor call.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundNewEx.TypeRef">
            <summary>
            Instantiated class type name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundNewEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundThrowExpression">
            <summary>
            throw <c>Thrown</c>;
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundThrowExpression.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundEcho">
            <summary>
            Specialized <c>echo</c> function call.
            To be replaced with <c>Context.Echo</c> once overload resolution is implemented.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundEcho.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundConcatEx">
            <summary>
            Represents a string concatenation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundConcatEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundIncludeEx">
            <summary>
            A script inclusion.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.IsOnceSemantic">
            <summary>
            True for <c>include_once</c> or <c>require_once</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.IsRequireSemantic">
            <summary>
            True for <c>require</c> or <c>require_once</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.IsResolved">
            <summary>
            Gets value indicating the target is resolved at compile time,
            so it will be called statically.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.TargetMethod">
            <summary>
            In case the inclusion target is resolved, gets reference to the <c>Main</c> method of the included script.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.InclusionType">
            <summary>
            Type of inclusion, <c>include</c>, <c>require</c>, <c>include_once</c>, <c>require_once</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundIncludeEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundLambda">
            <summary>
            Anonymous function expression.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundLambda.UseVars">
            <summary>
            Declared use variables.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundLambda.BoundLambdaMethod">
            <summary>
            Reference to associated lambda method symbol.
            Bound during analysis.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundLambda.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundEvalEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundExitEx">
            <summary>
            <c>exit</c> construct.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundExitEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundAssertEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundAssignEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundCompoundAssignEx.SearchForTargetVisitor">
            <summary>
            Searches for an occurance of <see cref="F:Pchp.CodeAnalysis.Semantics.BoundCompoundAssignEx.SearchForTargetVisitor._target"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundCompoundAssignEx.IsSafeToUnroll(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression,Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Determines if <paramref name="target"/> is not referenced within <paramref name="rvalue"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundCompoundAssignEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundIncDecEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundConditionalEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayEx.EmitCachedPhpArray(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Caches the array instance into an internal app-static field,
            so repetitious creations only uses the existing instance.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayEx.BoundArrayInitializer.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundArrayEx.Items">
            <summary>
            Array items.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx">
            <summary>
            Array item access.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx._emittedArrays">
            <summary>
            Stack of type of {array,index} emitted by <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitLoadValue(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> and <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.PushEmittedArray(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> and <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> remembers what was the array type it emitted.
            Used by <see cref="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.PopEmittedArray"/> and <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitLoadValue(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> or <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStore(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> to emit specific operator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.PopEmittedArray">
            <summary>
            Used by <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitLoadValue(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> and <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStore(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundAccess)"/> to emit specific operator
            on a previously emitted array (<see cref="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.PushEmittedArray(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)"/>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.EmitLoadIndex(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,System.Boolean)">
            <summary>
            Emits <see cref="P:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.Index"/> either as <c>PhpValue</c> or <c>IntStringKey</c> if possible safely.
            If <see cref="P:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.Index"/> is a <c>null</c> reference, nothing is emitted and <c>null</c> is returned by the function.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArrayItemOrdEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundInstanceOfEx.Operand">
            <summary>
            The value to be checked.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundInstanceOfEx.AsType">
            <summary>
            The type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundInstanceOfEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types">
            <summary>
            Pseudo-constant type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Line">
            <summary>__LINE__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.File">
            <summary>__FILE__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Class">
            <summary>__CLASS__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Trait">
            <summary>__TRAIT__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Function">
            <summary>__FUNCTION__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Method">
            <summary>__METHOD__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Namespace">
            <summary>__NAMESPACE__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.Dir">
            <summary>__DIR__</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Types.RootPath">
            <summary><code>Context.RootPath</code></summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundPseudoConst.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundPseudoClassConst.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundGlobalConst.Name">
            <summary>
            Constant name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundGlobalConst.FallbackName">
            <summary>
            Alternative constant name if <see cref="P:Pchp.CodeAnalysis.Semantics.BoundGlobalConst.Name"/> is not resolved.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundGlobalConst._boundExpressionOpt">
            <summary>
            In case the constant is resolved to a place.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundGlobalConst.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIsEmptyEx.Operand">
            <summary>
            Reference to be checked if it is set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundIsEmptyEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundIsSetEx.VarReference">
            <summary>
            Reference to be checked if it is set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundIsSetEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundOffsetExists.Receiver">
            <summary>
            The array.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundOffsetExists.Index">
            <summary>
            The index.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundTryGetItem">
            <summary>
            Shortcut for <c>isset($Array[$Index]) ? $Array[$Index] : Fallback</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundYieldEx">
            <summary>
            Represents a reference to an item sent to the generator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundYieldEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundYieldFromEx">
            <summary>
            Represents a return from `yield from` expression.
            That is the value returned from eventual `Generator` being yielded from.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundYieldFromEx.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundStatement">
            <summary>
            Base class representing a statement semantic.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundEmptyStatement._span">
            <summary>
            Explicit text span used to generate sequence point.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundEmptyStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundExpressionStatement">
            <summary>
            Represents an expression statement.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpressionStatement.Microsoft#CodeAnalysis#Operations#IExpressionStatementOperation#Operation">
            <summary>
            Expression of the statement.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundExpressionStatement.Expression">
            <summary>
            Expression of the statement.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundExpressionStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundReturnStatement">
            <summary>
            return <c>optional</c>;
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundReturnStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundFunctionDeclStatement">
            <summary>
            Conditionally declared functions.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundFunctionDeclStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundTypeDeclStatement">
            <summary>
            Conditionally declared class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeDeclStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundGlobalVariableStatement.Variable">
            <summary>
            The variable that will be referenced to a global variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundGlobalVariableStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundStaticVariableStatement.StaticVarDecl.Name">
            <summary>
            Variable name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundStaticVariableStatement.HolderClass">
            <summary>
            Synthesized type containing <c>value</c> field with the actual value.
            Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundStaticVariableStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundGlobalConstDeclStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundUnset.Variable">
            <summary>
            Reference to be unset.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundUnset.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundYieldStatement">
            <summary>
            Represents yield return and continuation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundYieldStatement.YieldIndex">
            <summary>
            The yield expression unique ordinal value within the routine.
            Indexed from one.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundYieldStatement.IsYieldFrom">
            <summary>
            Gets value indicating the `yield` is a part of `yield from` semantics.
            In result, keys yielded by this statement do not update Generator auto-incremented keys.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundYieldStatement.ContainingTryScopes">
            <summary>
            "try" scopes in which is this statement included ("catch" and "finally" are handled differently).
            Generator state machine may only jump before these scopes (CIL does not allow jumping into).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundYieldStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundDeclareStatement.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.LhsStack">
            <summary>
            A helper maintaining what is loaded on stack when storing a chained variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LhsStack.Stack">
            <summary>
            Loaded value on stack.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LhsStack.StackByRef">
            <summary>
            Loaded value on stack is address.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LhsStack.IsEnabled">
            <summary>
            Gets value whether to store receiver in temporary variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.VariableReferenceExtensions.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.IPlace,Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Emits preamble to an assignment.
            </summary>
            <param name="place">Target place to be assigned to.</param>
            <param name="cg">Ref to <see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator"/>.</param>
            <param name="access">The place's access.</param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.VariableReferenceExtensions.EmitLoadValue(Pchp.CodeAnalysis.Semantics.IVariableReference,Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            NOTICE: temporary API, will be replaced with operators.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.IVariableReference">
            <summary>
            An object specifying a reference to a variable, a field, a property, an array item (a value in general).
            Used by <see cref="T:Pchp.CodeAnalysis.Semantics.BoundReferenceExpression"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IVariableReference.Symbol">
            <summary>
            Optional.
            Gets the referenced symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IVariableReference.Type">
            <summary>
            Gets native type of the variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IVariableReference.HasAddress">
            <summary>
            Gets value indicating the native value can be accessed by address (<c>ref</c>).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IVariableReference.Place">
            <summary>
            Optional. Gets <see cref="T:Pchp.CodeAnalysis.CodeGen.IPlace"/> referring to the variable.
            </summary>
            <remarks>May be initialized lazily before emit and not during the analysis phase yet.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Prepare store operation for given access.
            Returns information on what was loaded onto the stack (receiver).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStore(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Stores the value on stack into the variable.
            </summary>
            <param name="cg">Reference to <see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator"/>.</param>
            <param name="lhs">Receiver loaded on stack by previous call to <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)"/>.</param>
            <param name="stack">Value loaded on stack to be stored into the variable.</param>
            <param name="access">Access information.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitLoadValue(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Loads value with given access.
            </summary>
            <param name="cg">Reference to <see cref="T:Pchp.CodeAnalysis.CodeGen.CodeGenerator"/>.</param>
            <param name="lhs">Receiver loaded on stack with previous call to <see cref="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitStorePreamble(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.BoundAccess)"/>.</param>
            <param name="access">Access information.</param>
            <returns>Loaded value (by value).</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IVariableReference.EmitLoadAddress(Pchp.CodeAnalysis.CodeGen.CodeGenerator,Pchp.CodeAnalysis.Semantics.LhsStack@)">
            <summary>
            Loads value with given access.
            </summary>
            <returns>Loaded value (by ref).</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.LocalVariableReference">
            <summary>
            Base class for local variables, parameters, $this, static locals and temporary (synthesized) locals.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalVariableReference.VariableKind">
            <summary>Variable kind.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalVariableReference.Name">
            <summary>Name of the variable.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalVariableReference.IsOptimized">
            <summary>
            Whether the variable is regular local on stack.
            Otherwise the variable is loaded from special ".locals" array of variables.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalVariableReference.Routine">
            <summary>Containing routine symbol. Cannot be <c>null</c>.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.LocalVariableReference.EmitInit(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits initialization of the variable if needed.
            Called from within <see cref="T:Pchp.CodeAnalysis.Semantics.Graph.StartBlock"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.LocalVariableReference.LoadIndirectLocal(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Template: IndirectLocal.Create( LOCALS, NAME )
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ParameterReference.IParameterSource">
            <summary>
            Describes the parameter source place.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ParameterReference.IParameterSource.EmitPass(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>Inplace copies the parameter.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ParameterReference.IParameterSource.EmitLoad(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>Loads copied parameter value.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ParameterReference.IParameterTarget">
            <summary>
            Describes the local variable target slot.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ParameterReference.DirectParameter">
            <summary>
            Parameter or local is real CLR value on stack.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ParameterReference.DirectParameter.EmitLoad(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>Loads copied parameter value.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ParameterReference.IndirectParameterSource">
            <summary>
            Parameter is fake and is stored in {varargs} array.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ParameterReference.IndirectLocalTarget">
            <summary>
            Local variables are unoptimized, parameter must be stored in {locals} array.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.InvokeReference">
            <summary>
            Represens call to Func`2{Context, TResult}.Invoke.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.None">
            <summary>
            Serves for case when Expression is body of a ExpressionStmt.
            It is useless to push its value on the stack in that case.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.Read">
            <summary>
            The result value will be read first.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.Write">
            <summary>
            A value will be written to the place.
            Only available for VariableUse (variables, fields, properties, array items, references).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.ReadRef">
            <summary>
            The expression will be aliased and the alias will be read.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.WriteRef">
            <summary>
            An aliased value will be written to the place.
            Only available for VariableUse (variables, fields, properties, array items, references).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.ReadQuiet">
            <summary>
            Read is check only and won't result in an exception in case the variable does not exist.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.EnsureObject">
            <summary>
            The expression is accessed as a part of chain,
            its member field will be written to.
            E.g. (EnsureObject)->Field = Value
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.EnsureArray">
            <summary>
            The expression is accessed as a part of chain,
            its item entry will be written to.
            E.g. (EnsureArray)[] = Value
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.Unset">
            <summary>
            The variable will be unset. Combined with <c>quiet</c> flag, valid for variables, array entries and fields.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.Isset">
            <summary>
            The variable will be checked whether it is set.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.AccessMask.IsNotRef">
            <summary>
            A flag denotating a value that is not aliased.
            This is a hint for code generators.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundAccess">
            <summary>
            Expression access information.
            Describes the context in which an expression is used.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundAccess._flags">
            <summary>
            The expression access kind - read, write, ensured.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundAccess._targetType">
            <summary>
            Optional. Type the expression will be converted to.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.BoundAccess._writeTypeMask">
            <summary>
            Type information for the write access (right value of the assignment).
            In case of <see cref="P:Pchp.CodeAnalysis.Semantics.BoundAccess.EnsureArray"/>, the type represents the written element type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsRead">
            <summary>
            In case the expression's value will be read.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsWrite">
            <summary>
            In case a value will be written to the variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsUnset">
            <summary>
            In case a variable will be unset.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsIsSet">
            <summary>
            In case the expression is read within <c>isset</c> operation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsNotRef">
            <summary>
            A flag denotating a value that is not aliased.
            In case of read access, it denotates the source value.
            In case of write access, it denotates the assignment target.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.WriteMask">
            <summary>
            Gets type of value to be written.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.TargetType">
            <summary>
            Optional.
            Type the expression will be implicitly converted to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Flags">
            <summary>
            Gets inyternal access flags.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsReadRef">
            <summary>
            The variable will be aliased and read.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsWriteRef">
            <summary>
            A reference will be written.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsNone">
            <summary>
            The expression won't be read or written to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsQuiet">
            <summary>
            The read is for check purposes only and won't result in a warning in case the variable does not exist.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsEnsure">
            <summary>
            In case we might change the variable content to array, object or an alias (we may need write access).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.MightChange">
            <summary>
            Gets value indicating the variable might be changed in context of the access.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.WriteRef">
            <summary>
            In case an alias will be written to the variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.EnsureObject">
            <summary>
            In case the expression has to read as an object to allow writing its fields.
            In case of a variable, created object has to be written back.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.EnsureArray">
            <summary>
            In case variable will be accessed as array in manner of setting its entries.
            <code>VARIABLE[] = ...</code>
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundAccess.ToString">
            <summary>
            Gets human readable access flags.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundAccess.WithRefFlag(System.Boolean)">
            <summary>
            Creates <see cref="T:Pchp.CodeAnalysis.Semantics.BoundAccess"/> value with specified <see cref="P:Pchp.CodeAnalysis.Semantics.BoundAccess.IsNotRef"/> flag.
            </summary>
            <param name="mightBeRef">Whether the value might be a reference (aliased) value.</param>
            <returns>New access.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Read">
            <summary>
            Simple read access.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.ReadRef">
            <summary>
            Read as a reference access.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Write">
            <summary>
            Simple write access without bound write type mask.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Unset">
            <summary>
            Unset variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Isset">
            <summary>
            Check for isset.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.None">
            <summary>
            Expression won't be read or written to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundAccess.ReadAndWrite">
            <summary>
            Read and write without bound write type mask
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundArgument.IsUnpacking">
            <inheritdoc/>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundArgument.ParameterName">
            <inheritdoc/>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArgument.Create(Pchp.CodeAnalysis.Semantics.BoundExpression,System.String)">
            <summary>
            Creates the argument.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundArgument.CreateUnpacking(Pchp.CodeAnalysis.Semantics.BoundExpression,System.String)">
            <summary>
            Creates the argument that will be unpacked.
            The argument is an array which elements will be passed as actual arguments.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundRoutineName">
            <summary>
            Direct or indirect routine name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundRoutineName.ToStringOrThrow">
            <summary>
            Gets <see cref="P:Pchp.CodeAnalysis.Semantics.BoundRoutineName.NameValue"/> as string if the name is known.
            Otherwise (when <see cref="P:Pchp.CodeAnalysis.Semantics.BoundRoutineName.NameExpression"/> is used instead), throws <see cref="T:System.InvalidOperationException"/> exception.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundTemporalVariableRef">
            <summary>
            A non-source synthesized variable reference that can be read or written to. 
            </summary>
            <remarks>
            Inheriting from <c>BoundVariableRef</c> is just a temporary measure. Do NOT take dependencies on anything but <c>IReferenceExpression</c>.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTemporalVariableRef.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>Invokes corresponding <c>Visit</c> method on given <paramref name="visitor"/>.</summary>
            <param name="visitor">A reference to a <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance. Cannot be <c>null</c>.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundOperation.Microsoft#CodeAnalysis#IOperation#ConstantValue">
            <summary>
            Resolved value of the expression.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundVariable">
            <summary>
            Represents a variable within routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariable.VariableKind">
            <summary>
            Variable kind.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariable.Symbol">
            <summary>
            Associated symbol, local or parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundVariable.Name">
            <summary>
            Name of the variable.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundThisParameter">
            <summary>
            Represents <c>$this</c> variable in PHP code.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ConversionKind">
            <summary>
            Possible conversion operation.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.ConversionKind.Numeric">
            <summary>
            A numeric conversion only.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.ConversionKind.Reference">
            <summary>
            Cast the CLR object reference.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.ConversionKind.Strict">
            <summary>
            Strict type conversion.
            Throws an exception if type does not match and numeric conversion does not exist.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.ConversionKind.Implicit">
            <summary>
            Implicit conversion.
            Produces a default value and a warning if conversion is not successful.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.ConversionKind.Explicit">
            <summary>
            Explicit casting.
            Always quiet conversion if conversion is possible.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Conversions.ConvCost(Microsoft.CodeAnalysis.Operations.CommonConversion,Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Calculates "cost" of conversion.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Conversions.IsSpecialReferenceType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Checks the type is a reference type (derived from <c>System.Object</c>) but it has a special meaning in PHP's semantics.
            Such a type cannot be converted to Object by simple casting.
            Includes: string, resource, array, alias.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ExpressionsExtension.WithContext``1(``0,Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Copies semantic information (<see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.Access"/>, <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.PhpSyntax"/>) from another expression.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ExpressionsExtension.IsEmptyStringValue(System.Object)">
            <summary>
            Gets value indicating the object will be an empty string after converting to string.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ExpressionsExtension.CanHaveSideEffects(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Returns whether the expression can possibly have any side effects.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ExpressionsExtension.AllowSequencePoint(Devsense.PHP.Syntax.Ast.LangElement)">
            <summary>
            Whether a sequence point should be emitted for the given expression statement.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpOperation.PhpSyntax">
            <summary>
            Corresponding syntax node.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IPhpOperation.Accept``1(Pchp.CodeAnalysis.Semantics.PhpOperationVisitor{``0})">
            <summary>
            Visitor with return value implementation.
            </summary>
            <typeparam name="TResult">Result type of the <paramref name="visitor"/>, <see cref="T:Peachpie.CodeAnalysis.Utilities.VoidStruct"/> if none.</typeparam>
            <param name="visitor">A reference to <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/> instance.</param>
            <returns>The value returned by the <paramref name="visitor"/>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.IPhpExpression">
            <summary>
            Abstract PHP expression semantic.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpExpression.TypeRefMask">
            <summary>
            Analysed type information.
            The type is bound to a <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/> associated with containing routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpExpression.Access">
            <summary>
            The way the expression is accessed.
            May specify an additional operation or conversion.
            May specify the type that the expression will be converted to.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpExpression.RequiresContext">
            <summary>
            Whether the expression needs current <c>Context</c> to be evaluated.
            If not, the expression can be evaluated in compile time or in app context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpExpression.IsDeeplyCopied">
            <summary>
            Decides whether an expression represented by this operation should be copied if it is passed by value (assignment, return).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpArgumentOperation.IsUnpacking">
            <summary>
            Variable unpacking in PHP, the triple-dot syntax.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IPhpArgumentOperation.ParameterName">
            <summary>
            If not <c>null</c>, specifies the named argument.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.LocalsTable">
            <summary>
            Table of local variables used within routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalsTable.Variables">
            <summary>
            Enumeration of direct local variables.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalsTable.Count">
            <summary>
            Count of local variables.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.LocalsTable.Routine">
            <summary>
            Containing routine. Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.LocalsTable.#ctor(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Initializes table of locals of given routine.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.LocalsTable.BindLocalVariable(Devsense.PHP.Syntax.VariableName,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets local variable or create local if not yet.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.CompilationSymbolsExtension">
            <summary>
            Provides helper methods for resolving functions, files and types in a context (aka semantic model).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.CompilationSymbolsExtension.HasPhpExtenion(Pchp.CodeAnalysis.PhpCompilation,System.String)">
            <summary>
            Gets value indicating the extension is defined in compilation time.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.CompilationSymbolsExtension.ResolveFunction(Pchp.CodeAnalysis.PhpCompilation,Devsense.PHP.Syntax.QualifiedName,Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Get global function symbol by its name in current context.
            Can be <c>null</c> if function could not be found.
            Can be an <see cref="T:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol"/> in case there are more functions possible or possible overrides.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider._lazyExportedTypes">
            <summary>
            Types that are visible from extension libraries.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider._lazyExportedFunctions">
            <summary>
            Functions that are visible from extension libraries.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.ReferencedPhpPackageReferences">
            <summary>
            Enumerates referenced assemblies which are extension libraries (has PhpExtensionAttribute).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.ExportedTypes">
            <summary>
            (PHP) Types exported from extension libraries and cor library.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.GetScriptsFromReferencedAssemblies">
            <summary>
            Gets script classes from referenced assemblies.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.ExportedScripts">
            <summary>
            Gets scripts used within the compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.GetReferencedTypes">
            <summary>
            Gets PHP types exported from referenced extension libraries and cor library.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.Compilation">
            <summary>
            Gets declaring compilation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.Model.GlobalSymbolProvider.Extensions">
            <summary>
            Gets enumeration of referenced extensions.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.ISymbolProvider">
            <summary>
            Represents PHP semantics.
            Used to query semantic questions about the compilation in specific context.
            </summary>
            <remarks>Use <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> once we implement <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.ISymbolProvider.Compilation">
            <summary>
            Gets declaring compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ISymbolProvider.ResolveFile(System.String)">
            <summary>
            Gets a file by its path relative to current context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ISymbolProvider.ResolveType(Devsense.PHP.Syntax.QualifiedName,System.Collections.Generic.Dictionary{Devsense.PHP.Syntax.QualifiedName,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Gets type symbol by its name in current context.
            Can be <c>null</c> if type cannot be found.
            Gets <see cref="T:Pchp.CodeAnalysis.Symbols.AmbiguousErrorTypeSymbol"/> in case of an ambiguity.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ISymbolProvider.ResolveFunction(Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Get global function symbol by its name in current context.
            Can be <c>null</c> if function could not be found.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.ISymbolProvider.ResolveConstant(System.String)">
            <summary>
            Resolves single global constant valid in current context.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1">
            <summary>
            Base visitor for PHP operations.
            </summary>
            <typeparam name="TResult">Return type of all the Visit operations, use <see cref="T:Peachpie.CodeAnalysis.Utilities.VoidStruct"/> if none.</typeparam>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1.Accept(Pchp.CodeAnalysis.Semantics.IPhpOperation)">
            <summary>Visits given operation.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundItemsBag`1">
            <summary>
            Holds currently bound item and optionally the first and the last BoundBlock containing all the statements that are supposed to go before the BoundElement. 
            </summary>
            <typeparam name="T">Either <c>BoundExpression</c> or <c>BoundStatement</c>.</typeparam>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundItemsBag`1.Empty">
            <summary>
            An empty bag with no item and no pre-bound blocks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundItemsBag`1.SingleBoundElement">
            <summary>
            Returns bound element and asserts that there are no <c>PreBoundStatements</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.SemanticsBinder">
            <summary>
            Binds syntax nodes (<see cref="T:Devsense.PHP.Syntax.Ast.LangElement"/>) to semantic nodes (<see cref="T:Microsoft.CodeAnalysis.IOperation"/>).
            Creates unbound nodes.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Semantics.SemanticsBinder._locals">
            <summary>
            Optional. Local variables table.
            Can be <c>null</c> for expressions without variable access (field initializers and parameters initializers).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.Self">
            <summary>
            Optional. Self type context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.ContainingFile">
            <summary>
            Containing file symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.Routine">
            <summary>
            Gets corresponding routine.
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.Yields">
            <summary>
            Found yield statements (needed for ControlFlowGraph)
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.StatesCount">
            <summary>
            Generated state machine states.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.Diagnostics">
            <summary>
            Bag with semantic diagnostics.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.DeclaringCompilation">
            <summary>
            Compilation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BoundTypeRefFactory">
            <summary>Gets <see cref="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BoundTypeRefFactory"/> instance.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.SemanticsBinder.EnableAssertExpression">
            <summary>
            Gets value determining whether to compile <c>assert</c>. otherwise the expression is ignored.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.Create(Pchp.CodeAnalysis.PhpCompilation,Microsoft.CodeAnalysis.SyntaxTree,Pchp.CodeAnalysis.Semantics.LocalsTable,Pchp.CodeAnalysis.Symbols.SourceTypeSymbol)">
            <summary>
            Creates <see cref="T:Pchp.CodeAnalysis.Semantics.SemanticsBinder"/> for given routine (passed with <paramref name="locals"/>).
            </summary>
            <param name="file">Containing file.</param>
            <param name="locals">Table of local variables within routine.</param>
            <param name="self">Current self context.</param>
            <param name="compilation">Declaring compilation.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.SetupBuilder(System.Func{Pchp.CodeAnalysis.Semantics.Graph.BoundBlock})">
            <summary>
            Provides binder with CFG builder.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BindIsMemberOfChain(Devsense.PHP.Syntax.Ast.Expression,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Optimization:
            Binds chain of <see cref="P:Devsense.PHP.Syntax.Ast.VarLikeConstructUse.IsMemberOf"/> expressions using own stack
            in order to avoid <see cref="T:System.StackOverflowException"/> for really long expression chains.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BindReadRefAccess(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            Updates <paramref name="expr"/>'s <see cref="T:Pchp.CodeAnalysis.Semantics.BoundAccess"/> to <see cref="P:Pchp.CodeAnalysis.Semantics.BoundAccess.ReadRef"/>.
            </summary>
            <param name="expr">Expression which access has to be updated.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BindWriteAccess(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            Updates <paramref name="expr"/>'s <see cref="T:Pchp.CodeAnalysis.Semantics.BoundAccess"/> to <see cref="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Write"/>.
            </summary>
            <param name="expr">Expression which access has to be updated.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.SemanticsBinder.BindEnsureArrayAccess(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            Updates <paramref name="expr"/>'s <see cref="T:Pchp.CodeAnalysis.Semantics.BoundAccess"/> to <see cref="P:Pchp.CodeAnalysis.Semantics.BoundAccess.Write"/>.
            </summary>
            <param name="expr">Expression which access has to be updated.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.GeneratorSemanticsBinder.Yields">
            <summary>
            Found yield statements (needed for ControlFlowGraph)
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.GeneratorSemanticsBinder.MakeTmpCopyAndPrependAssigment(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Assigns an expression to a temp variable, puts the assigment to <c>_preCurrentlyBinded</c>, and returns reference to the temp variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.GeneratorSemanticsBinder.CreateConditionalEdge(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock,Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.Graph.BoundBlock,Pchp.CodeAnalysis.Semantics.Graph.BoundBlock,Pchp.CodeAnalysis.Semantics.Graph.BoundBlock,Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Creates a conditional edge and returns its endBlock.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.TypeRef.BoundPrimitiveTypeRef.IsNumber">
            <summary>
            Gets value indicating the type is <c>long</c> or <c>double</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.TypeRef.BoundIndirectTypeRef.ObjectTypeInfoSemantic">
            <summary>
            Gets value determining the indirect type reference can refer to an object instance which type is used to get the type info.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.TypeRef.BoundIndirectTypeRef.IsNullable">
            <summary>
            Always <c>false</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.TypeRef.BoundIndirectTypeRef.IsThisVariable">
            <summary>
            Whether this is <c>$this</c> variable used as a type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.TypeRef.BoundTypeRefFromSymbol">
            <summary>
            <see cref="T:Pchp.CodeAnalysis.Semantics.IBoundTypeRef"/> refering to resolved reference type symbol.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.TypeRef.BoundTypeRefFromPlace">
            <summary>
            Refers to a variable that contains value of <c>PhpTypeInfo</c>.
            The type cannot be resolved statically, only <see cref="M:Pchp.CodeAnalysis.Semantics.TypeRef.BoundTypeRefFromPlace.EmitLoadTypeInfo(Pchp.CodeAnalysis.CodeGen.CodeGenerator,System.Boolean)"/> is applicable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefExtensions.ResolveRuntimeType(Pchp.CodeAnalysis.Semantics.IBoundTypeRef,Pchp.CodeAnalysis.PhpCompilation)">
            <summary>
            Gets <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/> suitable to be used for the runtime operations.
            Does not return <c>null</c> nor <see cref="T:Pchp.CodeAnalysis.Symbols.ErrorTypeSymbol"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefExtensions.IsSelf(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Gets value indicating the <paramref name="tref"/> represents <c>self</c> keyword.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefExtensions.IsParent(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Gets value indicating the <paramref name="tref"/> represents <c>parent</c> keyword.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefExtensions.IsStatic(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Gets value indicating the <paramref name="tref"/> represents <c>static</c> keyword.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefFactory.#ctor(Pchp.CodeAnalysis.PhpCompilation)">
            <summary>
            Initializes new instance of <see cref="T:Pchp.CodeAnalysis.Semantics.BoundTypeRefFactory"/>.
            </summary>
            <param name="compilation">Bound compilation.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRefFactory.CreateFromPlace(Pchp.CodeAnalysis.CodeGen.IPlace)">
            <summary>Create type reference refering to a variable containing <c>PhpTypeInfo</c> value.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.IBoundTypeRef">
            <summary>
            Provides a type reference and binding to <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsNullable">
            <summary>
            Gets value indicting that the type allows a <c>NULL</c> reference.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsObject">
            <summary>
            Gets value indicating whether the type represents an object (class or interface) and not a primitive type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsArray">
            <summary>
            Gets value indicating whether the type represents an array.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsPrimitiveType">
            <summary>
            Gets value indicating whether the type represents a primitive type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsLambda">
            <summary>
            Gets value indicating whether the type represents a lambda function.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.LambdaReturnType">
            <summary>
            Gets type information of lambda return value.
            This value is valid for callables.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.ElementType">
            <summary>
            Gets merged type information of array items values.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.TypeArguments">
            <summary>
            In case of generic type reference, gets its bound type arguments.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.GetTypeRefMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Gets type mask of the type reference in given context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.Transfer(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Transfers this type reference to the target type context.
            The method may return <c>this</c> instance, it cannot return <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.ResolveTypeSymbol(Pchp.CodeAnalysis.PhpCompilation)">
            <summary>
            Resolve <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> if possible.
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Semantics.BoundTypeRef">
            <summary>
            Common <see cref="T:Pchp.CodeAnalysis.Semantics.IBoundTypeRef"/> implementation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRef.GetTypeRefMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Gets type mask of the type reference in given context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.BoundTypeRef.WithNullableMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>Add <c>NULL</c> type mask if <see cref="P:Pchp.CodeAnalysis.Semantics.BoundTypeRef.IsNullable"/> is set to <c>true</c>.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundTypeRef.ResolvedType">
            <summary>
            Lazily set type symbol if resolved.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Semantics.BoundTypeRef.Type">
            <summary>
            Alias to <see cref="P:Pchp.CodeAnalysis.Semantics.BoundTypeRef.ResolvedType"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.PhpOperationExtensions.IsConstant(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Returns whether the expression has constant value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.PhpOperationExtensions.IsLogicNegation(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression@)">
            <summary>
            Gets value indicating the expression is a logic negation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Semantics.PhpOperationExtensions.TargetAccess(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            Gets the <see cref="T:Pchp.CodeAnalysis.Semantics.BoundAccess"/> for writing operation.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MethodSymbol.EmitLoadRoutineInfo(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits load of cached <c>RoutineInfo</c> corresponding to this method.
            </summary>
            <returns>Type symbol of <c>RoutineInfo</c>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as newslot (as indicated by the presence of the "newslot" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all symbols, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsMetadataVirtual(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as virtual (as indicated by the presence of the "virtual" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all symbols, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.Kind">
            <summary>
            Returns value 'Method' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.HidesBaseMethodsByName">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature. 
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.HasThis">
            <summary>
            Gets value determining the method has special <c>this</c> hidden parameter at index <c>0</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.ReceiverType">
            <summary>
            If this method can be applied to an object, returns the type of object it is applied to.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MethodSymbol.Construct(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.TypeSymbol})">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic method instantiation, returns null.
            The map targets the original definition of the method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.CallsiteReducedFromMethod">
            <summary>
            If this method is a reduced extension method, returns the extension method that
            should be used at call site during ILGen. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsPhpHidden">
            <summary>
            Gets value indicating the method is annotated with [PhpHiddenAttribute] metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.ControlFlowGraph">
            <summary>
            For source routines, gets their control flow graph.
            Can be <c>null</c> for routines from PE or synthesized routines.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.RoutineName">
            <summary>
            Gets the routine name, equivalent to a PHP pseudoconstant <c>__FUNCTION__</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.MethodSymbol.IsGlobalScope">
            <summary>
            Whether routine represents a global code.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter, and dynamic.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo">
            <summary>
            Provides information about a method and its override.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.Method">
            <summary>
            Method to be overriden.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.RoutineName">
            <summary>
            Gets the routine name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.IsUnresolvedAbstract">
            <summary>
            The method is abstract with no possible override.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.HasOverride">
            <summary>
            Whether there is a possible override of <see cref="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.Method"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.ImplementsInterface">
            <summary>
            Whether the override resolves implementation of a newly introduced interface method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.Override">
            <summary>
            Metched override.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OverrideInfo.OverrideCandidate">
            <summary>
            A candidate override which signature does not match exactly the method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.ResolveOverrides(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Matches all methods that can be overriden (non-static, public or protected, abstract or virtual)
            within this type sub-tree (this type, its base and interfaces)
            with its override.
            Methods without an override are either abstract or a ghost stup has to be synthesized.
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.InterfacesVisit(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Pchp.CodeAnalysis.Symbols.NamedTypeSymbol},System.Collections.Generic.HashSet{Pchp.CodeAnalysis.Symbols.NamedTypeSymbol}@)">
            <summary>
            Add the type to the builder and then recurse on its interfaces.
            </summary>
            <remarks>
            Pre-order depth-first search.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.GetInterfacesToEmit">
            <summary>
            Gets the set of interfaces to emit on this type. This set can be different from the set returned by Interfaces property.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.GetMethodsToEmit">
            <summary>
            To represent a gap in interface's v-table null value should be returned in the appropriate position,
            unless the gap has a symbol (happens if it is declared in source, for example).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.MangleName">
            <summary>
            Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
            Must return False for a type with Arity == 0.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Constructors">
            <summary>
            Get the both instance and static constructors for this type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.IsInterface">
            <summary>
            Requires less computation than <see cref="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.TypeKind"/> == <see cref="F:Microsoft.CodeAnalysis.TypeKind.Interface"/>.
            </summary>
            <remarks>
            Metadata types need to compute their base types in order to know their TypeKinds, and that can lead
            to cycles if base types are already being computed.
            </remarks>
            <returns>True if this is an interface type.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that it is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.ShouldAddWinRTMembers">
            <summary>
            True if the type should have its WinRT interfaces projected onto .NET types and
            have missing .NET interface members added to the type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol is declared conditionally.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Layout">
            <summary>
            Type layout information (ClassLayout metadata and layout kind flags).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.EqualsComplicatedCases(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Helper for more complicated cases of Equals like when we have generic instantiations or types nested within them.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.GetTypeArgumentCustomModifiers(System.Int32)">
            <summary>
            Returns custom modifiers for the type argument that has been substituted for the type parameter. 
            The modifiers correspond to the type argument at the same ordinal within the <see cref="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.TypeArgumentsNoUseSiteDiagnostics"/>
            array.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic type instantiation, returns null.
            The map targets the original definition of the type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.ResolvePhpCtor(System.Boolean)">
            <summary>
            PHP constructor method in this class.
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Microsoft#CodeAnalysis#INamedTypeSymbol#Constructors">
            <summary>
            Get the both instance and static constructors for this type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Construct(Pchp.CodeAnalysis.Symbols.TypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Construct(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.Construct(System.Collections.Generic.IEnumerable{Pchp.CodeAnalysis.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments"></param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol">
            <summary>
            Declares a CLR field representing a PHP field (a class constant or a field).
            </summary>
            <remarks>
            Its CLR properties vary depending on <see cref="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.Initializer"/> and its evaluation.
            Some expressions have to be evaluated in runtime which causes the field to be contained in <see cref="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder"/>.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.RequiresContext">
            <summary>
            Whteher the field initializer requires a reference to current <c>Context</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.RequiresHolder">
            <summary>
            Gets value indicating whether the field has to be contained in <see cref="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.EnsureTypeRefContext">
            <summary>
            Field's <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/> instance.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.FieldKind">
            <summary>
            The PHP field kind - a class constant, an instance field or a static field.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.Initializer">
            <summary>
            Optional. The field initializer expression.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.PHPDocBlock">
            <summary>
            Optional associated PHPDoc block defining the field type hint.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol._accessibility">
            <summary>
            Declared accessibility - private, protected or public.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.SourceAttributes">
            <summary>
            Gets enumeration of property source attributes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.IsRedefinition">
            <summary>
            Gets value indicating whether this field redefines a field from a base type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.OverridenDefinition">
            <summary>
            Gets field from a base type that is redefined by this field.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.FieldAccessorProperty">
            <summary>
            Optional property that provides public access to <see cref="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.OverridenDefinition"/> if it is protected.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.IsConst">
            <summary>
            <c>const</c> whether the field is a constant and its value can be resolved as constant value.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.IsReadOnly">
            <summary>
            <c>readonly</c> applies to class constants that have to be evaluated at runtime.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFieldSymbol.IsStatic">
            <summary>
            Whether the field is real CLR static field.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceFileSymbol">
            <summary>
            Represents a file within the mudule as a CLR type.
            </summary>
            <remarks>
            namespace [DIR]{
                [PhpScript]
                statc class [FNAME] {
                    static PhpValue [Main](){ ... }
                }
            }</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.Functions">
            <summary>
            List of functions declared within the file.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.ContainedTypes">
            <summary>
            List of types declared within the file.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.MainMethod">
            <summary>
            Special main method representing the script global code.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.AddFunction(Pchp.CodeAnalysis.Symbols.SourceFunctionSymbol)">
            <summary>
            Lazily adds a function into the list of global functions declared within this file.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.GetDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Collects declaration diagnostics.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFileSymbol.DirectoryRelativePath">
            <summary>
            Gets relative path excluding the file name and trailing slashes.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol">
            <summary>
            Base symbol representing a method or a function from source.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.GetContextPlace(Pchp.CodeAnalysis.Emit.PEModuleBuilder)">
            <summary>
            Gets place referring to <c>Pchp.Core.Context</c> object.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.GetThisPlace">
            <summary>
            Gets place of <c>this</c> parameter in CLR corresponding to <c>current class instance</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.GetPhpThisVariablePlace(Pchp.CodeAnalysis.Emit.PEModuleBuilder)">
            <summary>
            Gets place of PHP <c>$this</c> variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.SynthesizeStubs(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates ghost stubs,
            i.e. methods with a different signature calling this routine to comply with CLR standards.
            </summary>
            <returns>List of additional overloads.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.SynthesizeOverloadsWithOptionalParameters(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Synthesizes method overloads in case there are optional parameters which explicit default value cannot be resolved as a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>.
            </summary>
            <remarks>
            foo($a = [], $b = [1, 2, 3])
            + foo() => foo([], [1, 2, 3)
            + foo($a) => foo($a, [1, 2, 3])
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.EmitParametersDefaultValue(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Emits initializers of all parameter's non-standard default values (such as PhpArray)
            within the type's static .cctor
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.TypeRefContext">
            <summary>
            Routine <see cref="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.TypeRefContext"/> instance.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.Flags">
            <summary>
            Routine flags lazily collected during code analysis.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.ResultTypeMask">
            <summary>
            Gets so far type-analysed routine result type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.IsReturnAnalysed">
            <summary>
            Marks whether the exit block or any block with a return statement was already processed at least once.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol._commonflags">
            <summary>Internal true/false values. Initially all false.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.ControlFlowGraph">
            <summary>
            Lazily bound semantic block.
            Entry point of analysis and emitting.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.UpdateControlFlowGraph(Pchp.CodeAnalysis.Semantics.Graph.ControlFlowGraph)">
            <summary>
            Sets the new value of <see cref="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.LocalsTable">
            <summary>
            Gets table of local variables.
            Variables are lazily added to the table.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.SyntaxReturnType">
            <summary>
            Specified return type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.Syntax">
            <summary>
            Gets routine declaration syntax.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.PHPDocBlock">
            <summary>
            Optionaly gets routines PHP doc block.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.ContainingFile">
            <summary>
            Reference to a containing file symbol.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol._implicitVarArg">
            <summary>Implicitly declared [params] parameter if the routine allows access to its arguments. This allows more arguments to be passed than declared.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.BuildImplicitParams">
            <summary>
            Builds implicit parameters before source parameters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.RequiresLateStaticBoundParam">
            <summary>
            Gets value indicating this routine requires a special {PhpTypeInfo static} parameter to resolve `static` reserved type inside the routine body.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.GetDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Collects declaration diagnostics.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.BuildSrcParams(System.Collections.Generic.IEnumerable{Devsense.PHP.Syntax.Ast.FormalParam})">
            <summary>
            Constructs routine source parameters.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.VarargsParam">
            <summary>
            Implicitly added parameter corresponding to <c>params PhpValue[] {arguments}</c>. Replaces all the optional parameters.
            !!IMPORTANT!! Its <see cref="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.Ordinal"/> specifies its position - all the source parameters with the same or higher ordinal are ignored.
            Can be <c>null</c> if not needed.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.GetParamsParameter">
            <summary>
            Gets params parameter or null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.ReturnsNull">
            <summary>
            Gets value indicating the routine can return <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.SourceAttributes">
            <summary>
            Gets enumeration of function attributes.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            virtual = IsVirtual AND NewSlot 
            override = IsVirtual AND !NewSlot
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.OverrideOfMethod">
            <summary>
            Gets value indicating the method is an override of another virtual method.
            In such a case, this method MUST be virtual.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceGlobalMethodSymbol">
            <summary>
            Global code as a static [Main] method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceGlobalMethodSymbol._mainMethod0">
            <summary>
            Real main method with <c>MainDelegate</c> signature.
            The method is generated lazily in order to provide method compatible with MainDelegate.
            <see cref="T:Pchp.CodeAnalysis.Symbols.SourceGlobalMethodSymbol"/> may have (usually have) a different return type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceGlobalMethodSymbol.SynthesizeMainMethodWrapper(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Main method wrapper in case it does not return PhpValue.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceMethodSymbol">
            <summary>
            Represents a PHP class method.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceFunctionSymbol">
            <summary>
            Represents a global PHP function.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceFunctionSymbol.IsConditional">
            <summary>
            Whether the function is declared conditionally.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceFunctionSymbol.EnsureRoutineInfoField(Pchp.CodeAnalysis.Emit.PEModuleBuilder)">
            <summary>
            A field representing the function info at runtime of type <c>RoutineInfo</c>.
            Lazily associated with index by runtime.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceLambdaSymbol.Container">
            <summary>
            The type containing declaration of this lambda method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceLambdaSymbol.UseThis">
            <summary>
            Whether <c>$this</c> is pased to the routine (non static lambda).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceLambdaSymbol.EnsureRoutineInfoField(Pchp.CodeAnalysis.Emit.PEModuleBuilder)">
            <summary>
            A field representing the function info at runtime.
            Lazily associated with index by runtime.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceLambdaSymbol.ClosureParameter">
            <summary>Parameter containing reference to <c>Closure</c> object.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceGeneratorSymbol">
            <summary>
            Synthesized method representing the generator state machine's next function.
            Signature: <code>static &lt;&gt;sm_(Context &lt;ctx&gt;, T @this, PhpArray &lt;locals&gt;, PhpArray &lt;tmpLocals&gt;, Generator generator)</code>
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceGeneratorSymbol.CreateParameters(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Parameters for <see cref="T:Pchp.CodeAnalysis.Symbols.SourceGeneratorSymbol"/> method are defined by <c>GeneratorStateMachineDelegate</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol">
            <summary>
            PHP class as a CLR type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.FinalizeMethodTable(Pchp.CodeAnalysis.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Collects methods that has to be overriden and matches with this declaration.
            Missing overrides are reported, needed ghost stubs are synthesized.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.FullName">
            <summary>
            Gets fully qualified name of the class.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.FullNameString">
            <summary><see cref="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.FullName"/> as string.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.ContextStore">
            <summary>
            Optional.
            A field holding a reference to current runtime context.
            Is of type <c>Context</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.RuntimeFieldsStore">
            <summary>
            Optional.
            A field holding array of the class runtime fields.
            Is of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.StaticsContainer">
            <summary>
            Optional.
            A nested class <c>__statics</c> containing class static fields and constants which are bound to runtime context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.InstanceConstructorFieldsOnly">
            <summary>
            Optional. A <c>.ctor</c> that ensures the initialization of the class without calling the PHP constructor.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.ContainingType">
            <summary>
            Type using the trait.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.Symbol">
            <summary>
            Constructed trait type symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.TraitInstanceField">
            <summary>
            private readonly T &lt;&gt;_t;
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.DeclaredAs">
            <summary>
            Specifies implementation of a trait method in containing class.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.DeclaredAs.SourceMethod">
            <summary>
            Trait method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.DeclaredAs.Accessibility">
            <summary>
            Method visibility in containing class.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.DeclaredAs.Name">
            <summary>
            Method name in containing class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.DeclaredAccessibility(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Gets real accessibility (visibility) of trait member.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.MembersMap">
            <summary>
            Map of visible trait members how to be declared in containing class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUse.GetMembers">
            <summary>
            Gets synthesized members (methods, properties, constants).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyBaseType">
            <summary>
            Resolved base type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyInterfacesType">
            <summary>
            Resolved base interfaces.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.IsMarkedUnreachable">
            <summary>
            Whether is this particular declaration unreachable according to the analysis.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.IsUnreachable">
            <summary>
            Whether this declarations or any of the ancestors is unreachable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.NextVersion">
            <summary>
            In case the declaration is ambiguous, this references symbol with alternative declaration.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.HasTraitUses">
            <summary>
            Gets value indicating the class uses traits.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.HasVersions">
            <summary>
            Gets value indicating the type declaration is ambiguous.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.AllReachableVersions(System.Collections.Generic.Dictionary{Devsense.PHP.Syntax.QualifiedName,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Enumerates all reachable versions of this declaration.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyMembers">
            <summary>
            Defined type members, methods, fields and constants.
            Does not include synthesized members.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyAttributes">
            <summary>
            Populated symbol attributes.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._postponedDiagnostics">
            <summary>
            In case the type is declared conditionally,
            postpone reporting the diagnostics so they might get ignored eventually.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.NewSelf">
            <summary>
            Creates instance of self to be used for creating new versions of the same type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.ResolveBaseTypes(System.Collections.Generic.Dictionary{Devsense.PHP.Syntax.QualifiedName,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Writes up <see cref="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyBaseType"/> and <see cref="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol._lazyInterfacesType"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TypeRefSymbol.TraitAdaptations">
            <summary>Optional. Trait adaptations.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.ResolveTypeSignature(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol,System.Collections.Generic.Dictionary{Devsense.PHP.Syntax.QualifiedName,Microsoft.CodeAnalysis.INamedTypeSymbol},Pchp.CodeAnalysis.PhpCompilation)">
            <summary>
            Gets type signature of the type [BaseType or NULL, Interface1, ..., InterfaceN, Trait1, ..., TraitN]
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.GetDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Collects declaration diagnostics.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TryGetMagicToString">
            <summary>
            Gets magic <c>__toString</c> method of class or <c>null</c>.
            Gets <c>null</c> if the type is trait or interface or <c>__toString</c> is not defined.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TryGetMagicInvoke">
            <summary>
            Gets magic <c>__invoke</c> method of class or <c>null</c>.
            Gets <c>null</c> if the type is trait or interface or <c>__invoke</c> is not defined.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TryGetDestruct">
            <summary>
            Gets <c>__destruct</c> method of class or <c>null</c>.
            Gets <c>null</c> if the type is trait or interface or <c>__destruct</c> is not defined.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.Syntax">
            <summary>
            Gets type declaration syntax node.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.IsConditional">
            <summary>
            Gets value indicating the type is declared conditionally.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.TraitUses">
            <summary>
            Bound trait uses.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.GetDeclaredMembers">
            <summary>
            Enumerates all members including fields that will be contained in <c>_statics</c> holder.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceTypeSymbol.ResolvePhpTypeAutoloadFlag">
            <summary>
            See <c>PhpTypeAttribute</c>
            - 0: type is not selected to be autloaded.<br/>
            - 1: type is marked to be autoloaded.<br/>
            - 2: type is marked to be autoloaded and it is the only unconditional declaration in its source file.<br/>
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder">
            <summary>
            Container for class static and const fields.
            Such fields have to be put in a separate container since they are instantiated in context of current request, not the app domain.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder.Fields">
            <summary>
            Gets enumeration of fields that will be emitted within this holder.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder.IsEmpty">
            <summary>
            Gets value indicating whether there are fields or constants.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol">
            <summary>
            An ArrayTypeSymbol represents an array type, such as int[] or object[,].
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of the array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.IsSZArray">
            <summary>
            Is this zero-based one-dimensional array, i.e. SZArray in CLR terms.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.Sizes">
            <summary>
            Specified sizes for dimensions, by position. The length can be less than <see cref="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the size specified.
            The most common case is none of the dimensions have the size specified - an empty array is returned.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.LowerBounds">
            <summary>
            Specified lower bounds for dimensions, by position. The length can be less than <see cref="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the lower bound specified.
            The most common case is all dimensions are zero bound - a null array is returned in this case.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.HasSameSizesAndLowerBoundsAs(Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol)">
            <summary>
            Note, <see cref="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.Rank"/> equality should be checked separately!!!
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.HasDefaultSizesAndLowerBounds">
            <summary>
            Normally C# arrays have default sizes and lower bounds - sizes are not specified and all dimensions are zero bound.
            This property should return false for any deviations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.SZArray">
            <summary>
            Represents SZARRAY - zero-based one-dimensional array 
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ArrayTypeSymbol.MDArray">
            <summary>
            Represents MDARRAY - multi-dimensional array (possibly of rank 1)
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.BaseAttributeData">
            <summary>
            Represents an attribute applied to a Symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.AttributeClass">
            <summary>
            Gets the attribute class being applied.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.AttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.ApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.ConstructorArguments">
            <summary>
            Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments
            and named arguments that are formal parameters to the constructor.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.NamedArguments">
            <summary>
            Gets the list of named field or property value arguments specified by this application of the attribute.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.BaseAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Compares the namespace and type name with the attribute's namespace and type name.
            Returns true if they are the same.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.BaseAttributeData.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> that represents the current AttributeData.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current AttributeData.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.CommonAttributeClass">
            <summary>
            Gets the attribute class being applied as an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.CommonAttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute as an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.CommonApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.BaseAttributeData.ShouldEmitAttribute(Pchp.CodeAnalysis.Symbol,System.Boolean,System.Boolean)">
            <summary>
            This method determines if an applied attribute must be emitted.
            Some attributes appear in symbol model to reflect the source code,
            but should not be emitted.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CSharpCustomModifier">
            <summary>
            Represents a custom modifier (modopt/modreq).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.CSharpCustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.FieldSymbol">
            <summary>
            Represents a field in a class, struct or enum
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.Initializer">
            <summary>
            Optional. Gets the initializer.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.HasNotNull">
            <summary>
            Value indicating the field has [NotNull] metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.AssociatedSymbol">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that 
            property/event. Otherwise returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsFixed">
            <summary>
            Returns true if this field was declared as "fixed".
            Note that for a fixed-size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.FixedSize">
            <summary>
            If IsFixed is true, the value between brackets in the fixed-size-buffer declaration.
            If IsFixed is false FixedSize is 0.
            Note that for fixed-a size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsPhpHidden">
            <summary>
            Gets value indicating the field is hidden from PHP reflection.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.FieldSymbol.FixedImplementationType(Pchp.CodeAnalysis.Emit.PEModuleBuilder)">
            <summary>
            If this.IsFixed is true, returns the underlying implementation type for the
            fixed-size buffer when emitted.  Otherwise returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsCapturedFrame">
            <summary>
            Returns true when field is a backing field for a captured frame pointer (typically "this").
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.CorrespondingTupleField">
            <summary>
            If this field represents a tuple element, returns a corresponding default element
             field. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsAbstract">
            <summary>
            Returns false because field can't be abstract.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsExtern">
            <summary>
            Returns false because field can't be defined externally.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsOverride">
            <summary>
            Returns false because field can't be overridden.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsSealed">
            <summary>
            Returns false because field can't be sealed.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsVirtual">
            <summary>
            Returns false because field can't be virtual.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.HasRuntimeSpecialName">
            <summary>
            True if this symbol has a runtime-special name (metadata flag RuntimeSpecialName is set).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.IsNotSerialized">
            <summary>
            True if this field is not serialized (metadata flag NotSerialized is set).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.MarshallingInformation">
            <summary>
            Describes how the field is marshalled when passed to native code.
            Null if no specific marshalling information is available for the field.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this field, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.FieldSymbol.TypeLayoutOffset">
            <summary>
            Offset assigned to the field when the containing type is laid out by the VM.
            Null if unspecified.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.NamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
            <returns>An IEnumerable containing all the namespaces that are members of this symbol.
            If this symbol has no namespace members, returns an empty IEnumerable. Never returns
            null.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.NamespaceKind">
            <summary>
            The kind of namespace: Module, Assembly or Compilation.
            Module namespaces contain only members from the containing module that share the same namespace name.
            Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
            Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.ContainingCompilation">
            <summary>
            The containing compilation for compilation namespaces.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace has Assembly or Compilation extent, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.ContainingAssembly">
            <summary>
            Containing assembly.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceSymbol.LookupNestedNamespace(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Lookup a nested namespace.
            </summary>
            <param name="names">
            Sequence of names for nested child namespaces.
            </param>
            <returns>
            Symbol for the most nested namespace, if found. Nothing 
            if namespace or any part of it can not be found.
            </returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ParameterSymbol.Microsoft#Cci#IParameterDefinition#GetDefaultValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets constant value to be stored in metadata Constant table.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.ExplicitDefaultValue">
            <summary>
            Returns the default value of the parameter. If <see cref="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.HasExplicitDefaultValue"/>
            returns false then DefaultValue throws an InvalidOperationException.
            </summary>
            <remarks>
            If the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type, then this property will return null.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.Initializer">
            <summary>
            Optional. Gets the initializer.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.DefaultValueField">
            <summary>
            In case there is a default value that cannot be represented by <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>,
            this gets a static readonly field containing the value.
            </summary>
            <remarks>
            In PHP it is possible to set parameter's default value which cannot be represented using <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>.
            In such case, the value is set to this runtime field and read if needed.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The "'this' parameter has ordinal -1.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.OriginalSymbolDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.ExplicitDefaultConstantValue">
            <summary>
            Returns the default value constant of the parameter, 
            or null if the parameter doesn't have a default value or 
            the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type.
            </summary>
            <remarks>
            This is used for emitting.  It does not reflect the language semantics
            (i.e. even non-optional parameters can have default values).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ParameterSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ParameterSymbol.CanBePassedTo(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Helper method that checks whether this parameter can be passed to anothers method parameter.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PointerTypeSymbol.#ctor(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PointerTypeSymbol.#ctor(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PropertySymbol._lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
            <remarks>
            In source, we regard a property as an indexer if it is declared with an IndexerDeclarationSyntax.
            From metadata, we regard a property if it has parameters and is a default member of the containing
            type.
            CAVEAT: To ensure that this property (and indexer Names) roundtrip, source properties are not
            indexers if they are explicit interface implementations (since they will not be marked as default
            members in metadata).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.IsIndexedProperty">
            <summary>
            True if this an indexed property; that is, a property with parameters
            within a [ComImport] type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PropertySymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.ReducedFrom">
            <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            Duplicates and cycles are removed, although the collection may include
            redundant constraints where one constraint is a base type of another.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.TypeParameterKind">
            <summary>
            The type parameter kind of this type parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.DeclaringType">
            <summary>
            The type that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.EffectiveBaseClassNoUseSiteDiagnostics">
            <summary>
            The effective base class of the type parameter (spec 10.1.5). If the deduced
            base type is a reference type, the effective base type will be the same as
            the deduced base type. Otherwise if the deduced base type is a value type,
            the effective base type will be the most derived reference type from which
            deduced base type is derived.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.EffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set (spec 10.1.5).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.DeducedBaseTypeNoUseSiteDiagnostics">
            <summary>
            The most encompassed type (spec 6.4.2) from the constraints.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.AllEffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set and any base interfaces of those
            interfaces. This is AllInterfaces excluding interfaces that are
            only implemented by the effective base type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.TypeParameterSymbol})">
            <summary>
            Helper method to force type parameter constraints to be resolved.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceCustomAttribute.TypeCtx">
            <summary>
            Associated  <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/> instance.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceCustomAttribute.Arguments">
            <summary>
            Attribute arguments.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceCustomAttribute.ArgumentsToJson">
            <summary>Simple AST to JSON serialization.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.AbstractTypeMap">
            <summary>
            Abstract base class for mutable and immutable type maps.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteMemberType(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Substitute for a type declaration.  May use alpha renaming if the container is substituted.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteNamedType(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Perform the substitution on the given type.  Each occurrence of the type parameter is
            replaced with its corresponding type argument from the map.
            </summary>
            <param name="previous">The type to be rewritten.</param>
            <returns>The type with type parameters replaced with the type arguments.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteTypesDistinctWithoutModifiers(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.TypeSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Pchp.CodeAnalysis.Symbols.TypeSymbol})">
            <summary>
            Substitute types, and return the results without duplicates, preserving the original order.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteNamedTypes(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.ErrorMethodKind.MagicCall">
            <summary>
            Method is actually a call to a magic method <c>__callStatic</c> or <c>__call</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IErrorMethodSymbol.OriginalSymbols">
            <summary>
            In case of an original method(s) causing error (not visible or ambiguous), gets their enumeration.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol.IsOverloadable">
            <summary>
            Gets value indicating the ambiguities are overloads of the same function.
            Otherwise <see cref="P:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol.Ambiguities"/> are different methods and only one of them is declared in runtime.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol.#ctor(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.MethodSymbol},System.Boolean)">
            <summary>
            Method symbol representing more overloads.
            </summary>
            <param name="ambiguities">List of ambigous symbols.</param>
            <param name="overloadable">
            Whether the ambiguities can be resolved by overload resolution (list of method overloads or library method overloads).
            Otherwise binding has to be postponed to runtime (source declares more functions with the same name).</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol.ContainingSymbol">
            <summary>
            Gets a common containing symbol or <c>null</c> if ambiguities have a different parent.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AnonymousTypeManager.Compilation">
            <summary> 
            Current compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AnonymousTypeManager.GetAllCreatedTemplates">
            <summary>
            Returns all templates owned by this type manager
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.AnonymousTypeManager._lazySynthesizedDelegates">
            <summary>
            Maps delegate signature shape (number of parameters and their ref-ness) to a synthesized generic delegate symbol.
            Unlike anonymous types synthesized delegates are not available through symbol APIs. They are only used in lowered bound trees.
            Currently used for dynamic call-site sites whose signature doesn't match any of the well-known Func or Action types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AnonymousTypeManager.SynthesizedDelegateKey.MakeTypeName">
            <summary>
            Produces name of the synthesized delegate symbol that encodes the parameter byref-ness and return type of the delegate.
            The arity is appended via `N suffix since in MetadataName calculation since the delegate is generic.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AnonymousTypeManager.GetCreatedSynthesizedDelegates(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Pchp.CodeAnalysis.Symbols.SynthesizedDelegateSymbol})">
            <summary>
            The set of synthesized delegates created by
            this AnonymousTypeManager.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.AnonymousTypeParameterSymbol">
            <summary>
            Represents an anonymous type template's type parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AssemblySymbol.AssemblyVersionPattern">
            <summary>
            Assembly version pattern with wildcards represented by <see cref="F:System.UInt16.MaxValue"/>,
            or null if the version string specified in the <see cref="T:System.Reflection.AssemblyVersionAttribute"/> doesn't contain a wildcard.
            
            For example, 
              AssemblyVersion("1.2.*") is represented as 1.2.65535.65535,
              AssemblyVersion("1.2.3.*") is represented as 1.2.3.65535.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AssemblySymbol.IsLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.AssemblySymbol.CorLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.SetCorLibrary(Pchp.CodeAnalysis.Symbols.AssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set the system assembly, which provides primitive 
            types like Object, String, etc., e.g. mscorlib.dll. 
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <returns>The symbol for the pre-defined type or an error type if the type is not defined in the core library.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the symbol for the pre-defined type from core library associated with this assembly.
            </summary>
            <returns>The symbol for the pre-defined type or an error type if the type is not defined in the core library.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Lookup a type within the assembly using its canonical CLR metadata name.
            </summary>
            <param name="metadataName"></param>
            <param name="includeReferences">
            If search within assembly fails, lookup in assemblies referenced by the primary module.
            For source assembly, this is equivalent to all assembly references given to compilation.
            </param>
            <param name="isWellKnownType">
            Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.
            </param>
            <param name="useCLSCompliantNameArityEncoding">
            While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
            </param>
            <param name="warnings">
            A diagnostic bag to receive warnings if we should allow multiple definitions and pick one.
            </param>
            <returns>Null if the type can't be found.</returns>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.AssemblySymbol._lazySpecialTypeMembers">
            <summary>
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.GetLinkedReferencedAssemblies">
            <summary>
            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Pchp.CodeAnalysis.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.AssemblySymbol.TryLookupForwardedMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Pchp.CodeAnalysis.Symbols.AssemblySymbol})">
            <summary>
            Look up the given metadata type, if it is forwarded.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEAttributeData">
            <summary>
            Represents a PE custom attribute
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
            the attribute.
            </summary>
            <param name="namespaceName"></param>
            <param name="typeName"></param>
            <returns>True if the attribute data matches.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEAttributeData.GetTargetAttributeSignatureIndex(Pchp.CodeAnalysis.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
            type symbol for the attribute.
            </summary>
            <param name="targetSymbol">Target symbol.</param>
            <param name="description">Attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.RetargetingAttributeData">
            <summary>
            Represents a retargeting custom attribute
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceAttributeData">
            <summary>
            Represents a Source custom attribute specification
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceAttributeData.ConstructorArgumentsSourceIndices">
            <summary>
            If the <see cref="P:Pchp.CodeAnalysis.Symbols.BaseAttributeData.ConstructorArguments"/> contains any named constructor arguments or default value arguments,
            it returns an array representing each argument's source argument index. A value of -1 indicates default value argument.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceAttributeData.GetTargetAttributeSignatureIndex(Pchp.CodeAnalysis.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
            in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
            and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
            well known attributes.
            </summary>
            <param name="targetSymbol">The symbol which is the target of the attribute</param>
            <param name="description">The attribute to match.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceAttributeData.GetSystemType(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Gets the System.Type type symbol from targetSymbol's containing assembly.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>System.Type type symbol.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedAttributeData">
            <summary>
            Class to represent a synthesized attribute
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SubstitutedNestedTypeSymbol">
            <summary>
            A named type symbol that results from substituting a new owner for a type declaration.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ConstructedNamedTypeSymbol">
            <summary>
            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreMember`1">
            <summary>
            Helper object caching a well-known symbol.
            </summary>
            <typeparam name="T">Type of the symbol.</typeparam>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.CoreMember`1.DeclaringClass">
            <summary>
            Declaring class. Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.CoreMember`1.MemberName">
            <summary>
            Member name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreMember`1.op_Implicit(Pchp.CodeAnalysis.Symbols.CoreMember{`0})~`0">
            <summary>Implicit cast to the symbol.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreMethod">
            <summary>
            Descriptor of a well-known method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreMethod._ptypes">
            <summary>
            Parametyer types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreMethod.ResolveSymbol(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Resolves <see cref="T:Pchp.CodeAnalysis.Symbols.MethodSymbol"/> of this descriptor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreConstructor">
            <summary>
            Descriptor of a well-known constructor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreOperator">
            <summary>
            Descriptor of a well-known operator method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreOperator.#ctor(Pchp.CodeAnalysis.Symbols.CoreType,System.String,Pchp.CodeAnalysis.Symbols.CoreType[])">
            <summary>
            Creates the descriptor.
            </summary>
            <param name="declaringClass">Containing class.</param>
            <param name="name">Operator name, without <c>op_</c> prefix.</param>
            <param name="ptypes">CLR parameters.</param>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreCast">
            <summary>
            Descriptor of a well-known cast operator method.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreMethods">
            <summary>
            Set of well-known methods declared in a core library.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.CoreMethods.ScriptAttribute_IsAutoloaded">
            <summary>Property name of <c>ScriptAttribute.IsAutoloaded</c>.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreType">
            <summary>
            Descriptor of a well-known type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreType.FullName">
            <summary>
            Gets full type name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.CoreType.Symbol">
            <summary>
            Gets associated symbol.
            </summary>
            <remarks>Assuming single singleton instance of pchpcor library.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreType.op_Implicit(Pchp.CodeAnalysis.Symbols.CoreType)~Pchp.CodeAnalysis.Symbols.NamedTypeSymbol">
            <summary>
            Implicit cast to type symbol.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.CoreTypes">
            <summary>
            Set of well-known types declared in core libraries.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PeachpieRuntimeNamespace">
            <summary>
            Root namespace for Peachpie Runtime types.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpExtensionAttributeFullName">
            <summary>
            Name of attribute class representing an extension library.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpTypeAttributeFullName">
            <summary>
            Name of attribute class representing a PHP type descriptor.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpScriptAttributeFullName">
            <summary>
            Name of attribute class representing a script type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PharAttributeFullName">
            <summary>
            Name of attribute class representing a PHAR archive script type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.TargetPhpLanguageAttributeFullName">
            <summary>
            Name of attribute class representing target PHP language specification.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.Context_DllLoader_T">
            <summary>
            Full name of Context+DllLoader&lt;&gt;.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpTraitAttributeName">
            <summary>
            Name of attribute class annotating trait declaration.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpFieldsOnlyCtorAttributeName">
            <summary>
            Name of <c>PhpFieldsOnlyCtorAttribute</c> class.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.CoreTypes.PhpMemberVisibilityAttributeName">
            <summary>
            Name of <c>PhpTraitMemberVisibilityAttribute</c> class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreTypes.GetTypeFromMetadataName(System.String)">
            <summary>
            Gets well-known core type by its full CLR name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.CoreTypes.GetTypeFromSymbol(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets well-known core type by associated symbol.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ErrorTypeSymbol">
            <summary>
            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an ErrorSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ErrorTypeSymbol.Substitute(Pchp.CodeAnalysis.Symbols.AbstractTypeMap)">
            <summary>
            Called by <see cref="M:Pchp.CodeAnalysis.Symbols.AbstractTypeMap.SubstituteType(Pchp.CodeAnalysis.Symbols.TypeSymbol)"/> to perform substitution
            on types with TypeKind ErrorType.  The general pattern is to use the type map
            to perform substitution on the wrapped type, if any, and then construct a new
            error type symbol from the result (if there was a change).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MissingMetadataTypeSymbol.Nested">
            <summary>
            Represents nested missing type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SymbolExtensions">
            <summary>
            SymbolExtensions for member symbols.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.GetParameters(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Get the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.GetMemberArity(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Return the arity of a member.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.IsParameterlessConstructor(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            NOTE: every struct has a public parameterless constructor either used-defined or default one
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.IsDefaultValueTypeConstructor(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            default zero-init constructor symbol is added to a struct when it does not define 
            its own parameterless public constructor.
            We do not emit this constructor and do not call it 
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.ConstructIfGeneric(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.TypeWithModifiers})">
            <summary>
            Returns a constructed named type symbol if 'type' is generic, otherwise just returns 'type'
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.IsNotNull(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Determines if
            - method symbol cannot return NULL. E.g. has return attribute [return: NotNullAttribute] or [return: CastToFalse]
            - parameter symbol cannot be NULL (has attribute [NotNullAttribute])
            - field symbol cannot be NULL (has [NotNullAttribute])
            - property cannot be NULL (has [NotNullAttribute])
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.GetContainingFileSymbol(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Gets file symbol containing given symbol.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.TryGetPhpTypeAttribute(Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol,Devsense.PHP.Syntax.QualifiedName@,System.Version@)">
            <summary>
            Resolves [PhpTypeAttribute] and resulting type name.
            Returns <c>false</c> in case the type is not declared as a PHP type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.MakeQualifiedName(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Gets type full qualified name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.PhpName(Pchp.CodeAnalysis.Symbol)">
            <summary>
            Gets the symbol name as it appears in PHP context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.PhpQualifiedName(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Gets PHP type qualified name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.IsPhpOptionalParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determines if parameter has a default value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.TryGetPhpTypeAttribute(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.String@,System.String@,System.Byte@)">
            <summary>
            Gets [PhpType] attribute and its parameters.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.TryGetPhpTypeAttribute(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.String@,System.String@,System.Byte@,System.Version@)">
            <summary>
            Gets [PhpType] attribute and its parameters.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SymbolExtensions.PhpExtensionAttributeValues(Microsoft.CodeAnalysis.AttributeData)">
            <summary>
            Gets the list of extension names specified in given <c>PhpExtensionAttribute</c>.
            </summary>
            <returns>Enumeration of extensin names. Never returns <c>null</c>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MissingAssemblySymbol">
            <summary>
            A <see cref="T:Pchp.CodeAnalysis.Symbols.MissingAssemblySymbol"/> is a special kind of <see cref="T:Pchp.CodeAnalysis.Symbols.AssemblySymbol"/> that represents
            an assembly that couldn't be found.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MissingNamespaceSymbol">
            <summary>
            A <see cref="T:Pchp.CodeAnalysis.Symbols.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Pchp.CodeAnalysis.Symbols.NamespaceSymbol"/> that represents
            a namespace that couldn't be found.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ModuleSymbol.ReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from ReferencedAssemblies and 
            from ReferencedAssemblySymbols correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            corresponding item.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Pchp.CodeAnalysis.Symbols.AssemblySymbol},Pchp.CodeAnalysis.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ModuleSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MutableTypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. Equivalent to !IsNamespace.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetMembersByPhpName(System.String)">
            <summary>
            Gets all the members with particular PHP name visible in PHP scope.
            </summary>
            <param name="name">The case-insensitive name of the symbol (method, field, constant).</param>
            <returns>An ImmutableArray containing all the members with given name.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns null.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types or namespaces described by a qualified name.
            </summary>
            <param name="qualifiedName">Sequence of simple plain names.</param>
            <returns>
            A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities), 
            or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist).
            </returns>
            <remarks>
            "C.D" matches C.D, C{T}.D, C{S,T}.D{U}, etc.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NamespaceOrTypeSymbol.LookupMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup an immediately nested type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedTypeName">
            Simple type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NonMissingAssemblySymbol._emittedNameToTypeMap">
            <summary>
            This is a cache similar to the one used by MetaImport::GetTypeByName
            in native compiler. The difference is that native compiler pre-populates 
            the cache when it loads types. Here we are populating the cache only
            with things we looked for, so that next time we are looking for the same 
            thing, the lookup is fast. This cache also takes care of TypeForwarders. 
            Gives about 8% win on subsequent lookups in some scenarios.     
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Pchp.CodeAnalysis.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.NullableContextKind">
            <summary>
            Used by symbol implementations (source and metadata) to represent the value
            that was mapped from, or will be mapped to a [NullableContext] attribute.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.Unknown">
            <summary>
            Uninitialized state
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.None">
            <summary>
            No [NullableContext] attribute
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.Oblivious">
            <summary>
            [NullableContext(0)]
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.NotAnnotated">
            <summary>
            [NullableContext(1)]
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.Annotated">
            <summary>
            [NullableContext(2)]
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextUtils.ObliviousAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.Oblivious"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextUtils.NotAnnotatedAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.NotAnnotated"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.NullableContextUtils.AnnotatedAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Pchp.CodeAnalysis.Symbols.NullableContextKind.Annotated"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.OverloadsList">
            <summary>
            List of overloads for a function call.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope">
            <summary>
            Defines the scope of members visibility.
            Used to resolve visibility of called methods and accessed properties.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope.Scope">
            <summary>
            The type scope if resolved.
            Can be <c>null</c> when outside of class or when scope is unknown in compile-time.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope.ScopeIsDynamic">
            <summary>
            Whether the scope can change.
            In result visibility of private and protected members may change in runtime. 
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope.#ctor(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Builds the visibility scope.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverloadsList.Resolve(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Semantics.BoundArgument},Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope,Pchp.CodeAnalysis.Symbols.OverloadsList.InvocationKindFlags)">
            <summary>
            Tries to resolve method in design time.
            </summary>
            <returns>
            Might return one of following:
            - resolved single <see cref="T:Pchp.CodeAnalysis.Symbols.MethodSymbol"/>
            - <see cref="T:Pchp.CodeAnalysis.Symbols.MissingMethodSymbol"/>
            - <see cref="T:Pchp.CodeAnalysis.Symbols.AmbiguousMethodSymbol"/>
            - <see cref="T:Pchp.CodeAnalysis.Symbols.InaccessibleMethodSymbol"/>
            </returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverloadsList.RemoveInaccessible(System.Collections.Generic.List{Pchp.CodeAnalysis.Symbols.MethodSymbol},Pchp.CodeAnalysis.Symbols.OverloadsList.VisibilityScope)">
            <summary>
            Removes methods that are inaccessible for sure.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.OverrideHelper">
            <summary>
            Helper class resolving overriden method.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost">
            <summary>
            Conversion value used for overload resolution.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.Pass">
            <summary>
            No conversion is needed. Best case.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.PassCostly">
            <summary>
            The operation is costly but the value is kept without loosing precision.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.ImplicitCast">
            <summary>
            Conversion using implicit cast without loosing precision.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.LoosingPrecision">
            <summary>
            Conversion using explicit cast that may loose precision.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.Warning">
            <summary>
            Conversion is possible but the value is lost and warning should be generated.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.DefaultValue">
            <summary>
            Implicit value will be used, argument is missing and parameter is optional.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.TooManyArgs">
            <summary>
            Too many arguments provided. Arguments will be omitted.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.MissingArgs">
            <summary>
            Missing mandatory arguments, default values will be used instead.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.NoConversion">
            <summary>
            Conversion does not exist.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.OverrideHelper.ConversionCost.Error">
            <summary>
            Unspecified error.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.ResolveOverride(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Resolves best method to be overriden.
            </summary>
            <param name="method">The override.</param>
            <returns>Candidate to be overriden by given <paramref name="method"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.EnumerateOverridableTypes(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Enumerates base types and interfaces of given type (i.e. types that can contain methods that can be overriden).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.CanOverride(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Gets value indicating the given method can override another method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.OverrideCost(System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Pchp.CodeAnalysis.Symbols.ParameterSymbol})">
            <summary>
            Calculates override cost, i.e. whether the override is possible and its value.
            In case of more possible overrides, the one with better cost is selected.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.OverrideCost(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Calculates override cost, i.e. whether the override is possible and its value.
            In case of more possible overrides, the one with better cost is selected.
            </summary>
            <param name="method">Source method.</param>
            <param name="basemethod">A hypothetical base method.</param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.CanBeOverride(Pchp.CodeAnalysis.Symbols.SourceMethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Determines whether <paramref name="method"/> can override <paramref name="basemethod"/>.
            </summary>
            <param name="method">Source method.</param>
            <param name="basemethod">Overriden method.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverrideHelper.SignaturesMatch(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            Checks whether signatures of two methods match exactly so one can override the second.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.OverriddenOrHiddenMembersResult">
            <summary>
            Groups the information computed by MakeOverriddenOrHiddenMembers.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.OverriddenOrHiddenMembersResult.GetOverriddenMember">
            <summary>
            It is not suitable to call this method on a <see cref="T:Pchp.CodeAnalysis.Symbols.OverriddenOrHiddenMembersResult"/> object
            associated with a member within substituted type, <see cref="M:Pchp.CodeAnalysis.Symbols.OverriddenOrHiddenMembersResult.GetOverriddenMember(Pchp.CodeAnalysis.Symbol,Pchp.CodeAnalysis.Symbol)"/>
            should be used instead.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PE.MemberRefMetadataDecoder">
            <summary>
            This subclass of MetadataDecoder is specifically for finding
            method symbols corresponding to method MemberRefs.  The parent 
            implementation is unsuitable because it requires a PEMethodSymbol
            for context when decoding method type parameters and no such
            context is available because it is precisely what we are trying
            to find.  Since we know in advance that there will be no context
            and that signatures decoded with this class will only be used
            for comparison (when searching through the methods of a known
            TypeSymbol), we can return indexed type parameters instead.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PE.MemberRefMetadataDecoder._containingType">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PE.MemberRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
            <summary>
            We know that we'll never have a method context because that's what we're
            trying to find.  Instead, just return an indexed type parameter that will
            make comparison easier.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PE.MemberRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
            <summary>
            This override changes two things:
                1) Return type arguments instead of type parameters.
                2) Handle non-PE types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PE.MemberRefMetadataDecoder.FindMember(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Reflection.Metadata.MemberReferenceHandle,System.Boolean)">
            <summary>
            Search through the members of a given type symbol to find the method that matches a particular
            signature.
            </summary>
            <param name="targetTypeSymbol">Type containing the desired method symbol.</param>
            <param name="memberRef">A MemberRef handle that can be used to obtain the name and signature of the method</param>
            <param name="methodsOnly">True to only return a method.</param>
            <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.MetadataDecoder">
            <summary>
            Helper class to resolve metadata tokens and signatures.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.MetadataDecoder._typeContextOpt">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.MetadataDecoder._methodContextOpt">
            <summary>
            Method context for resolving generic method type arguments.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
            <param name="referencedAssemblyIndex"></param>
            <param name="emittedName"></param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in a module of a multi-module assembly.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.MetadataDecoder.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in this module.
            This method will be called only if the type we are
            looking for hasn't been loaded yet. Otherwise, MetadataDecoder
            would have found the type in TypeDefRowIdToTypeMap based on its 
            TypeDef row id. 
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol">
            <summary>
            Represents an assembly imported from a PE.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._assembly">
            <summary>
            An Assembly object providing metadata for the assembly.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._modules">
            <summary>
            The list of contained PEModuleSymbol objects.
            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
            can return it from Modules property as is.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._filePath">
            <summary>
            Optional full file path to the assembly.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._lazyCustomAttributes">
            <summary>
            Assembly's custom attributes
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._specialAssembly">
            <summary>
            The assembly purpose, and whether the compiler treats it as a .NET reference, PHP extension or a Cor library.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._lazyExtensionContainers">
            <summary>
            Public static classes containing public static methods and nested classes seen as global declarations in source module.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol._documentationProvider">
            <summary>
            A DocumentationProvider that provides XML documentation comments for this assembly.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol.LookupAssemblyForForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Look up the assembly to which the given metadata type is forwarded.
            </summary>
            <param name="emittedName"></param>
            <returns>
            The assembly to which the given type is forwarded or null, if there isn't one.
            </returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEAssemblySymbol.ExtensionContainers">
            <summary>
            Gets containers which members represent globals in source module context.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEFieldSymbol">
            <summary>
            The class to represent all fields imported from a PE/module.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEGlobalNamespaceSymbol._moduleSymbol">
            <summary>
            The module containing the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEMethodSymbol">
            <summary>
            The class to represent all methods imported from a PE/module.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEMethodSymbol.UncommonFields">
            <summary>
            Holds infrequently accessed fields. See <seealso cref="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._uncommonFields"/> for an explanation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEMethodSymbol.AccessUncommonFields">
            <summary>
            Ensures <see cref="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._uncommonFields"/> are created.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._uncommonFields">
            <summary>
            A single field to hold optional auxiliary data.
            In many scenarios it is possible to avoid allocating this, thus saving total space in <see cref="T:Pchp.CodeAnalysis.Symbols.PEModuleSymbol"/>.
            Even for lazily-computed values, it may be possible to avoid allocating <see cref="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._uncommonFields"/> if
            the computed value is a well-known "empty" value. In this case, bits in <see cref="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._packedFlags"/> are used
            to indicate that the lazy values have been computed and, if <see cref="F:Pchp.CodeAnalysis.Symbols.PEMethodSymbol._uncommonFields"/> is null, then
            the "empty" value should be inferred.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEMethodSymbol.SetAssociatedProperty(Pchp.CodeAnalysis.Symbols.PEPropertySymbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular property. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEMethodSymbol.SetAssociatedEvent(Pchp.CodeAnalysis.Symbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular event. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._assembly">
            <summary>
            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._module">
            <summary>
            A Module object providing metadata.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._namespace">
            <summary>
            Global namespace.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._lazySystemTypeSymbol">
            <summary>
            Cache the symbol for well-known type System.Type because we use it frequently
            (for attributes).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._lazyCustomAttributes">
            <summary>
            Module's custom attributes
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol._lazyAssemblyAttributes">
            <summary>
            Module's assembly attributes
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.DefaultTypeMapCapacity">
            <summary>
            The same value as ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.TypeHandleToTypeMap">
            <summary>
            This is a map from TypeDef handle to the target <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Pchp.CodeAnalysis.Symbols.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            as we load types from the module.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.TypeRefHandleToTypeMap">
            <summary>
            This is a map from TypeRef row id to the target <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Pchp.CodeAnalysis.Symbols.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            by <see cref="T:Pchp.CodeAnalysis.Symbols.MetadataDecoder"/> as we resolve TypeRefs from the module.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.GetCustomAttributesFilterExtensions(System.Reflection.Metadata.EntityHandle,System.Boolean@)">
            <summary>
            Filters extension attributes from the attribute results.
            </summary>
            <param name="token"></param>
            <param name="foundExtension">True if we found an extension method, false otherwise.</param>
            <returns>The attributes on the token, minus any ExtensionAttributes.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Returns a possibly ExtensionAttribute filtered roArray of attributes. If
            filterExtensionAttributes is set to true, the method will remove all ExtensionAttributes
            from the returned array. If it is false, the parameter foundExtension will always be set to
            false and can be safely ignored.
            
            The paramArrayAttribute parameter is similar to the foundExtension parameter, but instead
            of just indicating if the attribute was found, the parameter is set to the attribute handle
            for the ParamArrayAttribute if any is found and is null otherwise. This allows NoPia to filter
            the attribute out for the symbol but still cache it separately for emit.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@)">
            <summary>
            Get the custom attributes, but filter out any ParamArrayAttributes.
            </summary>
            <param name="token">The parameter token handle.</param>
            <param name="paramArrayAttribute">Set to a ParamArrayAttribute</param>
            CustomAttributeHandle if any are found. Nil token otherwise.
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEModuleSymbol.GetAssemblyForForwardedType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            If this module forwards the given type to another assembly, return that assembly;
            otherwise, return null.
            </summary>
            <param name="fullName">Type to look up.</param>
            <returns>Assembly symbol or null.</returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol">
            <summary>
            The class to represent all types imported from a PE/module.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.FullName">
            <summary>
            Gets fully qualified name of the class.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.ContextStore">
            <summary>
            Optional.
            A field holding a reference to current runtime context.
            Is of type <c>Context</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.RuntimeFieldsStore">
            <summary>
            Optional.
            A field holding array of the class runtime fields.
            Is of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.InstanceConstructorFieldsOnly">
            <summary>
            Optional. A <c>.ctor</c> that ensures the initialization of the class without calling the type PHP constructor.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.Pchp#CodeAnalysis#Symbols#IPhpScriptTypeSymbol#MainMethod">
            <summary>
            Gets method symbol representing the script entry point.
            The method's signature corresponds to <c>runtime:Context.MainDelegate</c> (Context ctx, PhpArray locals, object @this, RuntimeTypeHandle self).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.Pchp#CodeAnalysis#Symbols#IPhpScriptTypeSymbol#RelativeFilePath">
            <summary>
            Script's relative path to the application root.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.PENamedTypeSymbolNonGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with no type parameters in
            metadata (no type parameters on this type and all containing types).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol.PENamedTypeSymbolGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with type parameters in metadata.
            NOTE: the type may have Arity == 0 if it has same metadata arity as the metadata arity of the containing type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol._lazyMemberNames">
            <summary>
            A set of all the names of the members in this type.
            We can get names without getting members (which is a more expensive operation)
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol._lazyMembersInDeclarationOrder">
            <summary>
            We used to sort symbols on demand and relied on row ids to figure out the order between symbols of the same kind.
            However, that was fragile because, when map tables are used in metadata, row ids in the map table define the order
            and we don't have them.
            Members are grouped by kind. First we store fields, then methods, then properties, then events and finally nested types.
            Within groups, members are sorted based on declaration order.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol._lazyMembersByName">
            <summary>
            A map of members immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol._lazyMembersByPhpName">
            <summary>
            A map of members immediately contained within this type 
            grouped by their PHP name (case-insensitively, without special suffixes).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamedTypeSymbol._lazyNestedTypes">
            <summary>
            A map of types immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PENamespaceSymbol">
            <summary>
            The base class to represent a namespace imported from a PE/module. Namespaces that differ
            only by casing in name are not merged.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PENamespaceSymbol._types">
            <summary>
            A map of types immediately contained within this namespace 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PENamespaceSymbol.ContainingPEModule">
            <summary>
            Returns PEModuleSymbol containing the namespace.
            </summary>
            <returns>PEModuleSymbol containing the namespace.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Create symbols for nested types and initialize types map.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEParameterSymbol">
            <summary>
            The class to represent all method parameters imported from a PE/module.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PEParameterSymbol._lazyHiddenAttributes">
            <summary>
            Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEParameterSymbol.Create(Pchp.CodeAnalysis.Symbols.PEModuleSymbol,Pchp.CodeAnalysis.Symbols.PEPropertySymbol,System.Int32,System.Reflection.Metadata.ParameterHandle,Microsoft.CodeAnalysis.ParamInfo{Pchp.CodeAnalysis.Symbols.TypeSymbol},System.Boolean@)">
            <summary>
            Construct a parameter symbol for a property loaded from metadata.
            </summary>
            <param name="moduleSymbol"></param>
            <param name="containingSymbol"></param>
            <param name="ordinal"></param>
            <param name="handle">The property parameter doesn't have a name in metadata,
            so this is the handle of a corresponding accessor parameter, if there is one,
            or of the ParamInfo passed in, otherwise).</param>
            <param name="isBad" />
            <param name="parameter"></param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PEParameterSymbol.ImportConstantValue(System.Boolean)">
            <remarks>
            Internal for testing.  Non-test code should use <see cref="P:Pchp.CodeAnalysis.Symbols.PEParameterSymbol.ExplicitDefaultConstantValue"/>.
            </remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEPropertySymbol">
            <summary>
            The class to represent all properties imported from a PE/module.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEPropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name we imported.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEPropertySymbol.Initializer">
            <summary>
            Used for source symbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEPropertySymbol.HasNotNull">
            <summary>
            Value indicating the field has [NotNull] metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEPropertySymbol.IsIndexer">
            <remarks>
            This property can return true for bogus indexers.
            Rationale: If a type in metadata has a single, bogus indexer
            and a source method tries to invoke it, then Dev10 reports a bogus
            indexer rather than lack of an indexer.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PEPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this property, P, explicitly implements an interface property, IP, 
            if any of the following is true:
            
            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set
            2) P.get explicitly implements IP.get and there is no IP.set
            3) P.set explicitly implements IP.set and there is no IP.get
            
            Extra or missing accessors will not result in errors, P will simply not report that
            it explicitly implements IP.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PEPropertyOrEventHelpers">
            <summary>
            Helper methods that exist to share code between properties and events.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PETypeParameterSymbol">
            <summary>
            The class to represent all generic type parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PhpPropertyKind">
            <summary>
            The field kind.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol">
            <summary>
            Describes a PHP property.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.FieldKind">
            <summary>
            PHP property kind.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.ContainingStaticsHolder">
            <summary>
            In case field is contained in <c>__statics</c> holder class, gets its type.
            Otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.RequiresContext">
            <summary>
            Whether initialization of the field requires reference to runtime context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.DeclaringType">
            <summary>
            Type declaring this PHP property.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.EmitInit(Pchp.CodeAnalysis.CodeGen.CodeGenerator)">
            <summary>
            Emits initialization of the field.
            </summary>
            <param name="cg"></param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.DeclaredAccessibility">
            <summary>
            PHP property visibility.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpPropertySymbol.Name">
            <summary>
            PHP property name,
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol">
            <summary>
            A symbol representing PHP routine (function or method) in CLR.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol.CastToFalse">
            <summary>
            Gets value indicating whether <c>CastToFalseAttribute</c> applies to this routine and
            <c>null</c> reference or negative number must be converted to <c>false</c>.
            </summary>
            <remarks>Applies to library functions only.</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol.IsInitFieldsOnly">
            <summary>
            Gets value indicating the .ctor only initializes fields, and does not call __construct.
            Applicable only to instance constructors.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol.ControlFlowGraph">
            <summary>
            For source routines, gets their control flow graph.
            Can be <c>null</c> for routines from PE.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol.RoutineName">
            <summary>
            Gets a global function and a method name,
            otherwise an empty string.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol.IsGlobalScope">
            <summary>
            Gets value indicating the routine represents a global code.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpScriptTypeSymbol.MainMethod">
            <summary>
            Gets method symbol representing the script entry point.
            The method's signature corresponds to <c>runtime:Context.MainDelegate</c> (Context ctx, PhpArray locals, object @this, RuntimeTypeHandle self).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpScriptTypeSymbol.RelativeFilePath">
            <summary>
            Script's relative path to the application root.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol">
            <summary>
            A symbol representing PHP type in CLR.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.FullName">
            <summary>
            Gets fully qualified name of the class.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.IsTrait">
            <summary>
            Gets value indicating the class is declared as a trait.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.AutoloadFlag">
            <summary>
            Indicates how the type is being autoloaded in runtime:<br/>
            - 0: the class is not set for autoloading<br/>
            - 1: type is autoloaded<br/>
            - 2: type is autoloaded and the containing script does not have any sideeffects<br/>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.ContextStore">
            <summary>
            Optional.
            A field holding a reference to current runtime context.
            Is of type <c>Context</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.RuntimeFieldsStore">
            <summary>
            Optional.
            A field holding array of the class runtime fields.
            Is of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpTypeSymbol.InstanceConstructorFieldsOnly">
            <summary>
            Optional. A <c>.ctor</c> that does not make call to PHP constructor.
            This method is expected to be declared with <b>protected</b> visibility and
            used in context of a derived class constructor, since in PHP user calls PHP constructor explicitly.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.IPhpValue">
            <summary>
            An interface of symbols with a result value (field, routine, property).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpValue.Initializer">
            <summary>
            Optional. Gets the initializer.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.IPhpValue.HasNotNull">
            <summary>
            Gets flag indicating the value cannot be <c>NULL</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpFieldSymbolExtension.IsPhpStatic(Pchp.CodeAnalysis.Symbols.FieldSymbol)">
            <summary>
            Determines if given field is declared as static.
            Note: actual CLI metadata might be confusing since static PHP fields are represented as instance .NET fields in a class that lives within a PHP context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpFieldSymbolExtension.IsInStaticsHolder(Pchp.CodeAnalysis.Symbols.FieldSymbol)">
            <summary>
            Gets value indicating whether the field has to be contained in <see cref="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpFieldSymbolExtension.RequiresHolder(Pchp.CodeAnalysis.Symbols.FieldSymbol,Pchp.CodeAnalysis.Symbols.PhpPropertyKind)">
            <summary>
            Gets value indicating whether the field has to be contained in <see cref="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticFieldsHolder"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.PhpParam.IsAlias">
            <summary>
            Whether the parameter is passed as a PHP alias (<c>PhpAlias</c>).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PhpParam.IsByRef">
            <summary>
            Whether the parameter is passed as CLR <c>ref</c> or <c>out</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.PhpParam.IsPhpRw">
            <summary>
            Whether the parameter is annotated with <c>PhpRwAttribute</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.IsNotOverriding(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Gets value indicating the routine does not override any other routine.
            (static methods, private methods or sealed virtual methods not overriding anything)
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.ConstructClrReturnType(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Constructs most appropriate CLR return type of given routine.
            The method handles returning by alias, PHP7 return type, PHPDoc @return tag and result of flow analysis.
            In case the routine is an override or can be overriden, the CLR type is a value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.GetResultType(Pchp.CodeAnalysis.Symbols.IPhpValue,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Gets expected return type mask of given symbol (field, function, method or property).
            </summary>
            <remarks>Returned type mask corresponds to types that can be returned by invoking given symbol.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.GetExpectedArguments(Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Resolves list of input arguments.
            Implicit parameters passed by compiler are ignored.
            </summary>
            <param name="routine">Routine.</param>
            <param name="ctx">Type context to transfer type masks into.</param>
            <returns>List of input PHP arguments.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.GetByRefArguments(Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol)">
            <summary>
            Gets mask with 1-bits corresponding to an argument that must be passed by reference.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.InvocationFlags(Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol,System.Collections.Generic.IList{Devsense.PHP.Syntax.VariableName}@)">
            <summary>
            Gets additional flags of the caller routine.
            </summary>
            <param name="routine">The routine.</param>
            <param name="localaccess">Gets local variables that will be accessed by the routine. <c>NULL</c> if none (a common case).</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.HasLateStaticBoundParam(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Determines if the given routine uses late static binding i.e. `static` keyword or it forwards the late static type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.LateStaticParameter(Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Gets the special <c>&lt;static&gt;</c> parameter of given method if any. Otherwise <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.IsGeneratorMethod(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Gets value indicating the routine was found containing <c>yield</c>
            hence it is considered as a generator state machine method.
            </summary>
            <param name="routine">The analysed routine.</param>
            <returns>Value indicating the routine gets a generator.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.GetAllRoutines(Pchp.CodeAnalysis.Symbols.SourceFileSymbol)">
            <summary>
            Gets enumeration of all routines (global code, functions and methods) within the file.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.TryGetPHPDocBlock(Pchp.CodeAnalysis.Symbol,Devsense.PHP.Ast.DocBlock.IDocBlock@)">
            <summary>
            Gets PHPDoc assoviated with given source symbol.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpRoutineSymbolExtensions.GetSymbolMetadataResource(Pchp.CodeAnalysis.Symbol)">
            <summary>
            The resource contains an additional textual metadata to be used by the runtime if needed (JSON format).
            The resource is indexed by the symbol full metadata name.
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.PhpSignatureMask">
            <summary>
            Mask of single bits representing a true-false state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpSignatureMask.op_Implicit(Pchp.CodeAnalysis.Symbols.PhpSignatureMask)~System.UInt64">
            <summary>
            Implicitly converts the mask to <see cref="T:System.UInt64"/> mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpSignatureMask.op_BitwiseOr(Pchp.CodeAnalysis.Symbols.PhpSignatureMask,Pchp.CodeAnalysis.Symbols.PhpSignatureMask)">
            <summary>
            Combines two masks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpSignatureMask.SetFrom(System.Int32)">
            <summary>
            Sets all bits from given position to <c>1</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.TryGetStaticsHolder(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets special <c>_statics</c> nested class holding static fields bound to context.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.EnumerateProperties(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Enumerates class fields and properties as declared in PHP.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.ResolveInstanceProperty(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Resolves field or property on an instance.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.ResolveStaticField(Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Tries to find static field with given name.
            Lookups through the class inheritance.
            Does not handle member visibility.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.ResolveClassConstant(Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Tries to find class constant with given name.
            Lookups through the class inheritance.
            Does not handle member visibility.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.GetDependentSourceTypeSymbols(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol)">
            <summary>
            Gets (PHP) type symbols that has to be declared in order to declare given <paramref name="type"/>.
            </summary>
            <param name="type">The type declaration which dependant symbols will be returned.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.GetTypeKindKeyword(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets type kind as string, e.g. "class", "interface", "trait", ..
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.PhpTypeSymbolExtensions.GetPhpTypeNameOrNull(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            For known types, gets their PHP type name.
            Used for diagnostic reasons.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SignatureEqualityComparer">
            <summary>
            TODO: Helper comparer for methods signature and name equality. (overridable)
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.ILambdaContainerSymbol">
            <summary>
            A type container holding lambda declarations.
            TODO: LambdaSymbolManager
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ILambdaContainerSymbol.AddLambda(Pchp.CodeAnalysis.Symbols.SourceLambdaSymbol)">
            <summary>
            Adds declared lambda into this container.
            </summary>
            <param name="routine"></param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.ILambdaContainerSymbol.Lambdas">
            <summary>
            Gets lambda functions declared within this container.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.ILambdaContainerSymbol.ResolveLambdaSymbol(Devsense.PHP.Syntax.Ast.LambdaFunctionExpr)">
            <summary>
            Resolves lambda symbol for given syntax node.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.IndexedTypeParameterSymbol">
            <summary>
            Indexed type parameters are used in place of type parameters for method signatures.  There is
            a unique mapping from index to a single IndexedTypeParameterSymbol.  
            
            They don't have a containing symbol or locations.
            
            They do not have constraints, variance, or attributes. 
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.IndexedTypeParameterSymbol.Take(System.Int32)">
            <summary>
            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
            for the same position.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceAssemblySymbol._modules">
            <summary>
            A list of modules the assembly consists of. 
            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceAssemblySymbol.Flags">
            <summary>
            This represents what the user claimed in source through the AssemblyFlagsAttribute.
            It may be modified as emitted due to presence or absence of the public key.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourcePharEntrySymbol">
            <summary>
            <see cref="T:Pchp.CodeAnalysis.Symbols.SourceFileSymbol"/> representing a PHAR entry.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.VariableKind">
            <summary>
            Variable kind.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.LocalVariable">
            <summary>
            Variable is local in the routine.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.GlobalVariable">
            <summary>
            Variable is reference to a global variable.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.Parameter">
            <summary>
            Variable refers to a routine parameter.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.ThisParameter">
            <summary>
            Variable is <c>$this</c> variable.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.StaticVariable">
            <summary>
            Variable was introduced with <c>static</c> declaration.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.VariableKind.LocalTemporalVariable">
            <summary>
            Variable is a local synthesized variable, must be indirect.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceTraitMethodSymbol">
            <summary>
            Represents a PHP trait method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceModuleSymbol.SymbolCollection">
            <summary>
            Tables of all source symbols to be compiled within the source module.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol">
            <summary>
            Represents a PHP function parameter.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol._relindex">
            <summary>
            Index of the source parameter, relative to the first source parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.Initializer">
            <summary>
            Optional. The parameter initializer expression i.e. bound <see cref="P:Devsense.PHP.Syntax.Ast.FormalParam.InitValue"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.SourceAttributes">
            <summary>
            Gets enumeration of parameter source attributes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.CopyOnPass">
            <summary>
            Whether the parameter needs to be copied when passed by value.
            Can be set to <c>false</c> by analysis (e.g. unused parameter or only delegation to another method).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.Routine">
            <summary>
            Containing routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.IsConstructorProperty">
            <summary>
            The parameter is a constructor property.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.HasNotNull">
            <summary>
            Gets value indicating that if the parameters type is a reference type,
            it is not allowed to pass a null value.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.IsFake">
            <summary>
            Gets value indicating whether the parameter has been replaced with <see cref="P:Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol.VarargsParam"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceParameterSymbol.ParameterIndex">
            <summary>
            Zero-based index of the source parameter.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection">
            <summary>
            Collection of source symbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.SymbolsCache`2.Symbols">
            <summary>
            All symbols, both visible and not visible.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.SymbolsCache`2.Item(`0)">
            <summary>
            Gets all visible symbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.Version">
            <summary>
            Collection version, increased when a syntax tree is added or removed.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.Compilation">
            <summary>
            Gets reference to containing compilation object.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection._files">
            <summary>
            Set of files.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.DefinedConstantsContainer">
            <summary>
            Class holding app-static constants defined in compile-time.
            <code>static class &lt;constants&gt; { ... }</code>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.FirstScript">
            <summary>
            First script added to the collection.
            Used as a default entry script.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.SyntaxTrees">
            <summary>
            Gets compilation syntax trees.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.GetFunction(Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Gets function symbol, may return <see cref="T:Pchp.CodeAnalysis.Symbols.ErrorMethodSymbol"/> in case of ambiguity or a missing function.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.AllRoutines">
            <summary>
            Gets enumeration of all routines (global code, functions, lambdas and class methods) in source code.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.GetDeclaredTypes(Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Gets source declarations without versions.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.GetDeclaredTypes">
            <summary>
            Gets source declarations without versions.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SourceSymbolCollection.GetTypes">
            <summary>
            Gets all source types and their versions.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceTraitTypeSymbol">
            <summary>
            PHP trait symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SourceTraitTypeSymbol.RealThisField">
            <summary>
            Field holding actual <c>this</c> instance of the class that uses this trait.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SourceTraitTypeSymbol._lazyPhpTraitAttribute">
            <summary>[PhpTrait] attribute. Initialized lazily.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SourceAnonymousTypeSymbol">
            <summary>
            Symbol representing a PHP anonymous class.
            Builds a type similar to <b>internal sealed class [anonymous@class filename position]</b>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SpecialAssembly">
            <summary>
            Anumeration of well known assemblies.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialAssembly.None">
            <summary>
            Regular CLR assembly.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialAssembly.CorLibrary">
            <summary>
            Corresponds to system runtime library.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialAssembly.PeachpieCorLibrary">
            <summary>
            Corresponds to our runtime library (<c>Peachpie.Runtime</c>).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialAssembly.ExtensionLibrary">
            <summary>
            Denotates an assembly that contains the library extension.
            Such assembly is marked with assembly attribute <c>PhpExtensionAttribute</c>, it contains PHP types, functions or PHP scripts.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol">
            <summary>
            Synthetized routine parameter.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.ContextName">
            <summary>
            Name of special context parameter.
            Is of type <c>Context</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.LocalsName">
            <summary>
            Name of special locals parameter.
            Is of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.TemporaryLocalsName">
            <summary>
            Name of special locals parameter used for temporary variables used by compiler.
            Is of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.ParamsName">
            <summary>
            Synthesized params parameter.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.StaticTypeName">
            <summary>
            Name of special late-static-bound parameter.
            Is of type <c>PhpTypeInfo</c>
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.ThisName">
            <summary>
            Name of special <c>this</c> parameter.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.SelfName">
            <summary>
            Name of special <c>self</c> parameter.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.IsContextParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determines whether given parameter is treated as a special Context parameter
            which is always first and of type <c>Pchp.Core.Context</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.IsImportValueParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determines whether given parameter is treated as a special implicitly provided, by the compiler or the runtime.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.IsImportValueParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol,Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec@)">
            <summary>
            Determines whether given parameter is treated as a special implicitly provided, by the compiler or the runtime.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.IsLateStaticParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determines whether given parameter is a special lately static bound parameter.
            This parameter provides late static bound type, of type <c>PhpTypeInfo</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialParameterSymbol.IsSelfParameter(Pchp.CodeAnalysis.Symbols.ParameterSymbol)">
            <summary>
            Determines whether given parameter is a special self parameter.
            This parameter provides self type, of type <c>RuntimeTypeHandle</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialTypeExtensions.IsIntegralType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SpecialTypeExtensions.IsIntrinsicType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            The type is one of the simple types defined in Dev10 C#, see "predeftype.h"/simple
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SubstitutedNamedTypeSymbol">
            <summary>
            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they
            have type parameters substituted.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedCctorSymbol">
            <summary>
            Synthesized static constructor.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedContainer">
            <summary>
            A container synthesized for a lambda, iterator method, async method, or dynamic-sites.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedPhpCtorSymbol">
            <summary>
            Synthesized <c>.ctor</c> method (instance constructor) for PHP classes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedPhpCtorSymbol.BaseCtor">
            <summary>
            Base <c>.ctor</c> to be called by this method.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedPhpCtorSymbol.PhpConstructor">
            <summary>
            Optional. PHP constructor <c>__construct</c> to be called by this method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SynthesizedPhpCtorSymbol.CreateCtors(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol)">
            <summary>
            Creates CLS constructors for a PHP class.
            </summary>
            <param name="type">PHP class.</param>
            <returns>Enumeration of instance constructors for PHP class.</returns>
            <remarks>
            Constructors are created with respect to <c>base..ctor</c> and class PHP constructor function.
            At least a single <c>.ctor</c> is created which initializes fields and calls <c>base..ctor</c>. This is main constructor needed to properly initialize the class.
            In case there is a PHP constructor function:
            - The first ctor is marked as protected and is used only by other ctors and by derived classes to initialize class without calling the PHP constructor function.
            - Another ctor is created in order to call the main constructor and call PHP constructor function.
            - Ghost stubs of the other ctor are created in order to pass default parameter values which cannot be stored in metadata (e.g. array()).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedPhpTraitCtorSymbol.ThisParameter">
            <summary>.ctor parameter <c>object @this</c>.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedParameterlessPhpCtorSymbol">
            <summary>
            Context-less .ctor for a PHP class.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SynthesizedFieldSymbol.PackedFlags.AccessibilityMask">
            <summary>
            See <see cref="T:Microsoft.CodeAnalysis.Accessibility"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedInstanceMethodSymbol">
            <summary>
            A base class for synthesized methods that want a this parameter.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedInstanceMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedMethodSymbol.ForwardedCall">
            <summary>
            Optional.
            Gats actual method that will be called by this one.
            For informational purposes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedMethodSymbol.IsEditorBrowsableHidden">
            <summary>
            If set to <c>true</c>, the method will emit [EditorBrowsable(Never)] attribute.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedMethodSymbol.IsPhpHiddenInternal">
            <summary>
            If set to <c>true</c>, the method will emit [PhpHiddenAttribute] attribute.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SynthesizedMethodSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            virtual = IsVirtual AND NewSlot 
            override = IsVirtual AND !NewSlot
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedParameterSymbol">
            <summary>
            Represents a simple compiler generated parameter of a given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.SynthesizedParameterSymbol.DeriveParameters(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            For each parameter of a source method, construct a corresponding synthesized parameter
            for a destination method.
            </summary>
            <param name="sourceMethod">Has parameters.</param>
            <param name="destinationMethod">Needs parameters.</param>
            <returns>Synthesized parameters to add to destination method.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedScriptTypeSymbol">
            <summary>
            internal static class &lt;Script&gt; { ... }
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedScriptTypeSymbol.EntryPointSymbol">
            <summary>
            Optional. Real assembly entry point method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.SynthesizedScriptTypeSymbol._lazyMembers">
            <summary>
            Additional type members.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedStaticLocHolder">
            <summary>
            Nested class representing a static local variable.
            
            Template:
            class static'foo'x : IStaticInit {
                public T value;
                public void Init(Context ctx){ ... }
            }
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticLocHolder.DeclaringMethod">
            <summary>
            Containing source routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticLocHolder.VariableName">
            <summary>
            Name of the local variable.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticLocHolder.ValueType">
            <summary>
            Type of local variable.
            <c>PhpAlias</c> by default.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.SynthesizedStaticLocHolder.ValueField">
            <summary>
            The containing value represented as a class field.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedSubstitutedTypeParameterSymbol">
            <summary>
            A type parameter for a synthesized class or method.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedTraitMethodSymbol">
            <summary>
            Synthesized method representing implementation of used trait method inside a containing class.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.SynthesizedTypeSymbol">
            <summary>
            Synthesized non-generic static class.
            class { ... }
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)">
            <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
            <returns>A System.String that represents the current TypedConstant.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.TypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.TypeParameterBounds">
            <summary>
            The effective "bounds" of a type parameter: the constraint types, effective
            interface set, and effective base type, determined from the declared
            constraints, with any cycles removed. The fields are exposed by the
            TypeParameterSymbol as ConstraintTypes, Interfaces, and BaseType.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.TypeParameterBounds.ConstraintTypes">
            <summary>
            The type parameters, classes, and interfaces explicitly declared as
            constraint types on the containing type parameter, with cycles removed.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.TypeParameterBounds.Interfaces">
            <summary>
            The set of interfaces explicitly declared on the containing type
            parameter and any type parameters on which the containing
            type parameter depends, with duplicates removed.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.TypeParameterBounds.EffectiveBaseClass">
            <summary>
            As defined in 10.1.5 of the specification.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.TypeParameterBounds.DeducedBaseType">
            <summary>
            The "exact" effective base type. 
            In the definition of effective base type we abstract some concrete types to their base classes:
             * For each constraint of T that is a struct-type, R contains System.ValueType.
             * For each constraint of T that is an enumeration type, R contains System.Enum.
             * For each constraint of T that is a delegate type, R contains System.Delegate.
             * For each constraint of T that is an array type, R contains System.Array.
             * For each constraint of T that is a class-type C, R contains type C' which is constructed 
               from C by replacing all occurrences of dynamic with object.
            The reason is that the CLR doesn't support operations on generic parameters that would be needed 
            to work with these types. For example, ldelem instruction requires the receiver to be a specific array, 
            not a type parameter constrained to be an array.
            
            When computing the deduced type we don't perform this abstraction. We keep the original constraint T.
            Deduced base type is used to check that consistency rules are satisfied.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbols.TypeSymbol">
            <summary>
            A TypeSymbol is a base class for all the symbols that represent a type in PHP.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.PrimitiveTypeCode">
            <summary>
            Gets corresponding primitive type code for this type declaration.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.EffectiveTypeNoUseSiteDiagnostics">
            <summary>
            If this is a type parameter returns its effective base class, otherwise returns this type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.IsDerivedFrom(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if this type derives from a given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.IsEqualToOrDerivedFrom(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if this type is equal or derives from a given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.Equals(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Determines if this type symbol represent the same type as another, according to the language
            semantics.
            </summary>
            <param name="t2">The other type.</param>
            <param name="ignoreCustomModifiersAndArraySizesAndLowerBounds">True to compare without regard to custom modifiers, false by default.</param>
            <param name="ignoreDynamic">True to ignore the distinction between object and dynamic, false by default.</param>
            <returns>True if the types are equivalent.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.GetHashCode">
            <summary>
            We ignore custom modifiers, and the distinction between dynamic and object, when computing a type's hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.TypeSymbol.PhpCoreType">
            <summary>
            In case of PHP corlibrary type, gets reference to the descriptor <see cref="T:Pchp.CodeAnalysis.Symbols.CoreType"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.LookupMember``1(System.String,System.Func{``0,System.Boolean})">
            <summary>
            Lookup member of given name and type through base types and interfaces.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbol.LookupMethods(System.String)">
            <summary>
            Resolves PHP method by its name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.Expect(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Throws exception in type is not as expected.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.Expect(Pchp.CodeAnalysis.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Throws exception in type is not as expected.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.ExpectValid(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Assertion that type is valid.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsValidType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>Gets value indicating the type is not null, not ambiguous and not error type.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsPhpSourceFile(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Gets value indicating the type represents PHP script (<see cref="T:Pchp.CodeAnalysis.Symbols.SourceFileSymbol"/>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsPhpUserType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets value indicating the type is a PHP user type (declared in a PHP code).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsPhpType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets value indicating the type is a PHP type (annotated with [PhpTypeAttribute] (and/or declared in user's code).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.CanBePhpAlias(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Type is PhpValue or PhpAlias.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.Is_Func_Context_PhpValue(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Determines the type is <c>Func{Context,PhpValue}</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.Is_Func_Context_TResult(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol@)">
            <summary>
            Determines the type is <c>Func{Context,TResult}</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsByteArray(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>Gets value indicating the given type represents a <c>byte[]</c> array type.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsExpressionTree(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            return true if the type is constructed from System.Linq.Expressions.Expression`1
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsPossibleArrayGenericInterface(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            return true if the type is constructed from a generic interface that 
            might be implemented by an array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.GetDefaultValue(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Return the default value constant for the given type,
            or null if the default value is not a constant.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.VisitType``1(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Func{Pchp.CodeAnalysis.Symbols.TypeSymbol,``0,System.Boolean,System.Boolean},``0)">
            <summary>
            Visit the given type and, in the case of compound types, visit all "sub type"
            (such as A in A[], or { A&lt;T&gt;, T, U } in A&lt;T&gt;.B&lt;U&gt;) invoking 'predicate'
            with the type and 'arg' at each sub type. If the predicate returns true for any type,
            traversal stops and that type is returned from this method. Otherwise if traversal
            completes without the predicate returning true for any type, this method returns null.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.ContainsDynamic(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any dynamic type reference.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsRestrictedType(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Returns true if the type is one of the restricted types, namely: <see cref="T:System.TypedReference"/>, 
            <see cref="T:System.ArgIterator"/>, or <see cref="T:System.RuntimeArgumentHandle"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.MarkCheckedIfNecessary(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Pchp.CodeAnalysis.Symbols.TypeSymbol}@)">
            <summary>
            Add this instance to the set of checked types. Returns true
            if this was added, false if the type was already in the set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsVoid(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Gets value indicating the type is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsPrimitiveRecursiveStruct(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. <see cref="T:System.Int32"/> contains an instance field of type <see cref="T:System.Int32"/>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.ComputeHashCode(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Compute a hash code for the constructed type. The return value will be
            non-zero so callers can used zero to represent an uninitialized value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsVerifierReference(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered reference types by the verifier.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.IsVerifierValue(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered value types by the verifier.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Pchp.CodeAnalysis.Symbols.TypeParameterSymbol})">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeSymbolExtensions.HasNameQualifier(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,System.String)">
            <summary>
            Return true if the fully qualified name of the type's containing symbol
            matches the given name. This method avoids string concatenations
            in the common case where the type is a top-level type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbols.TypeWithModifiers.AsTypeSymbolOnly">
            <summary>
            Extract type under assumption that there should be no custom modifiers.
            The method asserts otherwise.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.GlobalRoutineName">
            <summary>
            Name of function representing a script global code.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.DefaultScriptClassName">
            <summary>
            Name of special script type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.ScriptsRootNamespace">
            <summary>
            Namespace containing all script types.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.PharEntryRootNamespace">
            <summary>
            Namespace containing script types corresponding to compiled Phar entry.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.StaticsHolderClassName">
            <summary>
            Name of special nested class containing context bound static fields and constants.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.GeneratorStateMachineNameFormatString">
            <summary>
            Format string for a generator state machine method name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.SynthesizedDisposedFieldName">
            <summary>
            Field with flag whether the class's Dispose() was called already.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Symbols.WellKnownPchpNames.LambdaMethodName">
            <summary>
            Name of method containing lambda method's implementation.
            This is PHP-like name that has to be equal <c>anonymous@function</c>
            so PHP <c>__FUNCTION__</c> constant and eventual reflection is compatible with regular PHP.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CommandLine.CommandLineDiagnosticFormatter.RelativizeNormalizedPath(System.String)">
            <summary>
            Get the path name starting from the <see cref="F:Pchp.CodeAnalysis.CommandLine.CommandLineDiagnosticFormatter._baseDirectory"/>
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CommandLine.PhpCommandLineArguments.CompilationOptions">
            <summary>
            Gets the compilation options for the PHP <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            created from the <see cref="T:Pchp.CodeAnalysis.CommandLine.PhpCompiler"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CommandLine.PhpCommandLineArguments.ParseOptions">
            <summary>
            Gets the parse options for the PHP <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.CommandLine.PhpCommandLineArguments.ShouldIncludeErrorEndLocation">
            <value>
            Should the format of error messages include the line and column of
            the end of the offending text.
            </value>
        </member>
        <member name="M:Pchp.CodeAnalysis.CommandLine.PhpCommandLineParser.TryParseEncodingName(System.String)">
            <summary>
            Extends support for encoding names in additon to codepages.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.CommandLine.PhpCommandLineParser.ParseFileArgumentWithoutFileNotFound(System.String,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Enumerates files in the directory and ignores diagnostics about missing files.
            <c>ERR_FileNotFound</c> is reported in case files are not found in the given directory, however,
            since we call this function repetitiously for more directories this error makes no sense just for one of them.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CommandLine.PhpCompiler">
            <summary>
            Implementation of <c>pchp.exe</c>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParsedSource">
            <summary>
            Result of the <see cref="M:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParseFile(System.IO.TextWriter,Pchp.CodeAnalysis.PhpParseOptions,Pchp.CodeAnalysis.PhpParseOptions,System.Boolean@,Microsoft.CodeAnalysis.CommandLineSourceFile,Microsoft.CodeAnalysis.ErrorLogger)"/> operation.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParsedSource.SyntaxTree">
            <summary>
            Resulting syntax tree of source file
            or a syntax tree of PHAR file stub.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParsedSource.Manifest">
            <summary>PHAR manifest in case the source file is a PHAR file.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParsedSource.Trees">
            <summary>PHAR syntax trees in case the source file is a PHAR file.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.CommandLine.PhpCompiler.ParsedSource.Resources">
            <summary>Additional resources.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpOptimizationLevel">
            <summary>
            Level of optimization.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpOptimizationLevel.Debug">
            <summary><see cref="F:Microsoft.CodeAnalysis.OptimizationLevel.Debug"/></summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpOptimizationLevel.Release">
            <summary><see cref="F:Microsoft.CodeAnalysis.OptimizationLevel.Release"/></summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpOptimizationLevelExtension">
            <summary>
            Helper methods for the <see cref="T:Pchp.CodeAnalysis.PhpOptimizationLevel"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpParseOptions">
            <summary>
            This class stores several source parsing related options and offers access to their values.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpParseOptions.Default">
            <summary>
            The default parse options.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpParseOptions.LanguageVersion">
            <summary>
            Gets required language version.
            <c>null</c> value respects the parser's default which is always the latest version.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpParseOptions.AllowShortOpenTags">
            <summary>
            Whether to allow the deprecated short open tag syntax.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable some experimental language features for testing.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpParseOptions.WithLanguageVersion(System.Version)">
            <summary>
            Language version.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.CreateEntryPoint(Pchp.CodeAnalysis.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Create real CIL entry point, where it calls given method.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.CreateMainMethodWrapper(Pchp.CodeAnalysis.Symbols.MethodSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Emits body of scripts main wrapper converting main result to <c>PhpValue</c>.
            </summary>
            <param name="wrapper">&lt;Main&gt;`0 method, that calls real Main.</param>
            <param name="main">Real scripts main method.</param>
            <param name="diagnostic">DiagnosticBag.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.Emit.PEModuleBuilder.ScriptType">
            <summary>
            Gets script type containing entry point and additional assembly level symbols.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Emit.PEModuleBuilder.SynthesizedManager">
            <summary>
            Manages synthesized methods and fields.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Emit.PEModuleBuilder._cctorBuilders">
            <summary>
            Builders for synthesized static constructors.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.GetSynthesizedFields(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets enumeration of synthesized fields for <paramref name="container"/>.
            </summary>
            <param name="container">Containing type symbol.</param>
            <returns>Enumeration of synthesized fields.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.GetSynthesizedProperties(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets enumeration of synthesized properties for <paramref name="container"/>.
            </summary>
            <param name="container">Containing type symbol.</param>
            <returns>Enumeration of synthesized properties.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.GetSynthesizedMethods(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets enumeration of synthesized methods for <paramref name="container"/>.
            </summary>
            <param name="container">Containing type symbol.</param>
            <returns>Enumeration of synthesized methods.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.GetSynthesizedTypes(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets enumeration of synthesized nested types for <paramref name="container"/>.
            </summary>
            <param name="container">Containing type symbol.</param>
            <returns>Enumeration of synthesized nested types.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.GetStaticCtorBuilder(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets IL builder for lazy static constructor.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEModuleBuilder.RealizeStaticCtors">
            <summary>
            Any lazily emitted static constructor will be realized and its body saved to method map.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SynthesizedManager">
            <summary>
            Manages synthesized symbols in the module builder.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.EnsureStaticCtor(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets or initializes static constructor symbol.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.GetOrCreateSynthesizedField(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.String,Microsoft.CodeAnalysis.Accessibility,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates synthesized field.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.AddNestedType(Microsoft.Cci.ITypeDefinition,Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Adds a type member to the class.
            </summary>
            <param name="container">Containing type.</param>
            <param name="nestedType">Type to be added as nested type.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.AddMethod(Microsoft.Cci.ITypeDefinition,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Adds a synthesized method to the class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.AddProperty(Microsoft.Cci.ITypeDefinition,Pchp.CodeAnalysis.Symbols.PropertySymbol)">
            <summary>
            Adds a synthesized property to the class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.AddField(Microsoft.Cci.ITypeDefinition,Pchp.CodeAnalysis.Symbols.FieldSymbol)">
            <summary>
            Adds a synthesized symbol to the class.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.GetMembers``1(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Gets synthezised members contained in <paramref name="container"/>.
            </summary>
            <remarks>
            This method is not thread-safe, it is expected to be called after all
            the synthesized members were added to <paramref name="container"/>.
            </remarks>
            <typeparam name="T">Type of members to enumerate.</typeparam>
            <param name="container">Containing type.</param>
            <returns>Enumeration of synthesized type members.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.SynthesizedManager.GetGlobalConstantIndexField(System.String)">
            <summary>
            Gets or creates internal static int field as index holder for a global constant.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.GenericMethodInstanceReference">
            <summary>
            Represents a reference to a generic method instantiation, closed over type parameters,
            e.g. MyNamespace.Class.Method{T}()
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.GenericNamespaceTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is not nested.
            e.g. MyNamespace.A{int}
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.GenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is nested in a non-generic type.
            e.g. A.B{int}
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.GenericTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation.
            Subclasses represent nested and namespace types.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Emit.PEAssemblyBuilder._metadataName">
            <summary>
            The behavior of the C# command-line compiler is as follows:
              1) If the /out switch is specified, then the explicit assembly name is used.
              2) Otherwise,
                 a) if the assembly is executable, then the assembly name is derived from
                    the name of the file containing the entrypoint;
                 b) otherwise, the assembly name is derived from the name of the first input
                    file.
            
            Since we don't know which method is the entrypoint until well after the
            SourceAssemblySymbol is created, in case 2a, its name will not reflect the
            name of the file containing the entrypoint.  We leave it to our caller to
            provide that name explicitly.
            </summary>
            <remarks>
            In cases 1 and 2b, we expect (metadataName == sourceAssembly.MetadataName).
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Emit.PEAssemblyBuilder.GetFiles(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of the files that constitute the assembly. These are not the source language files that may have been
            used to compile the assembly, but the files that contain constituent modules of a multi-module assembly as well
            as any external resources. It corresponds to the File table of the .NET assembly file format.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.PhpRootModuleType">
            <summary>
            Special type &lt;Module&gt;.
            See https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/PEWriter/RootModuleType.cs for original implementation.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SpecializedFieldReference">
            <summary>
            Represents a reference to a field of a generic type instantiation.
            e.g.
            A{int}.Field
            A{int}.B{string}.C.Field
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SpecializedGenericMethodInstanceReference">
            <summary>
            Represents a generic method of a generic type instantiation, closed over type parameters.
            e.g. 
            A{T}.M{S}()
            A.B{T}.C.M{S}()
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SpecializedGenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
            e.g. 
            A{int}.B{string}
            A.B{int}.C.D{string}
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SpecializedMethodReference">
            <summary>
            Represents a method of a generic type instantiation.
            e.g. 
            A{int}.M()
            A.B{int}.C.M()
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Emit.SpecializedNestedTypeReference">
            <summary>
            Represents a reference to a type nested in an instantiation of a generic type.
            e.g. 
            A{int}.B
            A.B{int}.C.D
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation._anonymousTypeManager">
            <summary>
            Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation._lazyAssemblySymbol">
            <summary>
            The <see cref="T:Pchp.CodeAnalysis.Symbols.SourceAssemblySymbol"/> for this compilation. Do not access directly, use Assembly property
            instead. This field is lazily initialized by ReferenceManager, ReferenceManager.CacheLockObject must be locked
            while ReferenceManager "calculates" the value and assigns it, several threads must not perform duplicate
            "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation._referenceManager">
            <summary>
            Holds onto data related to reference binding.
            The manager is shared among multiple compilations that we expect to have the same result of reference binding.
            In most cases this can be determined without performing the binding. If the compilation however contains a circular 
            metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.
            We do so by creating a new reference manager for such compilation. 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.CorLibrary">
            <summary>
            COR library containing base system types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.PhpCorLibrary">
            <summary>
            PHP COR library containing PHP runtime.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.SourceSymbolCollection">
            <summary>
            Tables containing all source symbols to be compiled.
            Used for enumeration and lookup.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.SourceAssembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.Assembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.UserDeclaredRoutines">
            <summary>
            Gets enumeration of all user declared routines (global code, functions, methods and lambdas) in the compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetUserDeclaredRoutinesInFile(Pchp.CodeAnalysis.PhpSyntaxTree)">
            <summary>
            Gets enumeration of user declared routines (global code, functions, methods and lambdas) in the specified file
            identified by its syntax tree.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.UserDeclaredTypes">
            <summary>
            Gets enumeration of all user declared types (classes, interfaces and traits) in the compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.Clone">
            <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.IsCaseSensitive">
            <summary>
            Returns true if this is a case sensitive compilation, false otherwise.  Case sensitivity
            affects compilation features such as name lookup as well as choosing what names to emit
            when there are multiple different choices (for example between a virtual method and an
            override).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.CommonSourceModule">
            <summary>
            Get a ModuleSymbol that refers to the module being created by compiling all of the code.
            By getting the GlobalNamespace property of that module, all of the namespaces and types
            defined in source code can be obtained.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.DeclarationDiagnostics">
            <summary>
            The bag in which semantic analysis should deposit its diagnostics.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetUnaliasedReferencedAssemblies(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Pchp.CodeAnalysis.Symbols.AssemblySymbol})">
            <summary>
            Return a list of assembly symbols than can be accessed without using an alias.
            For example:
              1) /r:A.dll /r:B.dll -> A, B
              2) /r:Foo=A.dll /r:B.dll -> B
              3) /r:Foo=A.dll /r:A.dll -> A
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.BindAndAnalyseTask">
            <summary>
            Ensures semantic binding and flow analysis.
            </summary>
            <returns>The result of the task contains enumeration of diagnostics.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.SourceMetadataResource">
            <summary>
            Gets resource of additional metadata for each of declared symbol.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.FilterAndAppendDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Filter out warnings based on the compiler options (/nowarn, /warn and /warnaserror) and the pragma warning directives.
            </summary>
            <returns>True when there is no error.</returns>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation._lazyWellKnownTypes">
            <summary>
            An array of cached well known types available for use in this Compilation.
            Lazily filled by GetWellKnownType method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation._lazyWellKnownTypeMembers">
            <summary>
            Lazy cache of well known members.
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.TypeRefFactory">
            <summary>
            Gets factory object for constructing <see cref="T:Pchp.CodeAnalysis.Semantics.BoundTypeRef"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.CoreTypes">
            <summary>
            Well known types associated with this compilation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.CoreMethods">
            <summary>
            Well known methods associated with this compilation.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.GlobalSemantics">
            <summary>
            Gets global semantics. To be replaced once we implement SyntaxNode (<see cref="M:Pchp.CodeAnalysis.PhpCompilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.Merge(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Merges two CLR types into one, according to PCHP type hierarchy.
            </summary>
            <param name="first">First type.</param>
            <param name="second">Second type.</param>
            <returns>One type convering both <paramref name="first"/> and <paramref name="second"/> types.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.FindCommonBase(Pchp.CodeAnalysis.Symbols.TypeSymbol,Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Resolves a <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/> that both given types share.
            Gets <c>System.Object</c> in worst case.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.MergeNull(Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Merges CLR type to be nullable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.IsNumber(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Determines whether given type is treated as a PHP number (<c>int</c> or <c>double</c>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.IsAString(Pchp.CodeAnalysis.Symbols.TypeSymbol)">
            <summary>
            Determines given type is treated as a string (UTF16 string or PHP string builder).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetTypeFromTypeRef(Devsense.PHP.Syntax.Ast.TypeRef,Pchp.CodeAnalysis.Symbols.SourceTypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Binds <see cref="T:Devsense.PHP.Syntax.Ast.TypeRef"/> to a type symbol.
            </summary>
            <param name="tref">Type reference.</param>
            <param name="selfHint">Optional.
            Current type scope for better <paramref name="tref"/> resolution since <paramref name="tref"/> might be ambiguous</param>
            <param name="nullable">Whether the resulting type must be able to contain NULL. Default is <c>false</c>.</param>
            <param name="phpLang">PHP semantic - specifies how to treat <c>int</c> and <c>string</c> special types.</param>
            <returns>Resolved symbol.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetConstantValueType(System.Object)">
            <summary>
            Resolves the value's type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
            <remarks>
            If a well-known member of a generic type instantiation is needed use this method to get the corresponding generic definition and 
            <see cref="M:Pchp.CodeAnalysis.Symbols.MethodSymbol.AsMember(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)"/> to construct an instantiation.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the Cor Library referenced by this
            compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetTypeFromTypeRef(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Resolves <see cref="T:Pchp.CodeAnalysis.Symbols.TypeSymbol"/> best fitting given type mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.GetTypeFromTypeRef(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Resolves <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> best fitting given type mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.ClassifyExplicitConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            PHP has a different semantic of explicit conversions,
            try to resolve explicit conversion first.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpCompilation.DynamicTransformsEncoder">
            <summary>
            Used to generate the dynamic attributes for the required typesymbol.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpCompilation.ReferenceManager._diagnostics">
            <summary>
            Diagnostics produced during reference resolution and binding.
            </summary>
            <remarks>
            When reporting diagnostics be sure not to include any information that can't be shared among 
            compilations that share the same reference manager (such as full identity of the compilation, 
            simple assembly name is ok).
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.ReferenceManager.CorLibrary">
            <summary>
            COR library containing base system types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilation.ReferenceManager.PhpCorLibrary">
            <summary>
            PHP COR library containing PHP runtime.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpCompilation.ReferenceManager.IsIdentitySimilar(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Checks the assembly identities are similar - this is a quick workaround to use assemblies as resolved by build system (versions might not match).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpCompilationOptions">
            <summary>
            Represents various options that affect compilation, such as 
            whether to emit an executable or a library, whether to optimize
            generated code, and so on.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.BaseDirectory">
            <summary>
            Compilation root directory.
            All script paths will be emitted relatively to this path.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.SubDirectory">
            <summary>
            A path where all the compiled scripts will be moved virtually.
            File "a/index.php" will be compiled into "<see cref="P:Pchp.CodeAnalysis.PhpCompilationOptions.SubDirectory"/>/a/index.php"
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.SdkDirectory">
            <summary>
            Compilation root directory.
            All script paths will be emitted relatively to this path.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.TargetFramework">
            <summary>
            What framework is the compiled assembly supposed to run on,
            e.g. <c>.NETCoreApp,Version=v3.1</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.EmbedSourceMetadata">
            <summary>
            Whether to generate an embedded resource containing additional information about the source symbols.
            Used by runtime for reflection.
            Default is <c>true</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.ParseOptions">
            <summary>
            Source language options.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.LanguageVersion">
            <summary>
            The compilation language version.
            Gets <see cref="P:Pchp.CodeAnalysis.PhpParseOptions.LanguageVersion"/> or default language version if not specified.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.Diagnostics">
            <summary>
            Options diagnostics.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.VersionString">
            <summary>
            The file version string.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.EventSources">
            <summary>
            List of observer instances.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.OptimizationLevel">
            <summary>
            The compilation optimization level.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.Defines">
            <summary>
            Set of compile-time defined constants.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.Autoload_ClassMapFiles">
            <summary>
            Set of relative file names from which class map will be generated.
            Contained types will be marked as autoloaded.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.Autoload_Files">
            <summary>
            Set of relative file names to be marked as autoloaded.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.Autoload_PSR4">
            <summary>
            Collection of PSR-4 autoload rules.
            Matching types (classes, traits and interfaces) will be marked as autoloaded.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpCompilationOptions.NullableContextOptions">
            <summary>
            Global Nullable context options.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.SourceCompiler">
            <summary>
            Performs compilation of all source methods.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.SourceCompiler.MaxTransformCount">
            <summary>
            Number of control flow graph transformation cycles to do at most.
            <c>0</c> to disable the lowering.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.EnqueueRoutine(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Enqueues routine's start block for analysis.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.EnqueueExpression(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Enqueues the standalone expression for analysis.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.EnqueueType(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol)">
            <summary>
            Enqueues initializers of a class fields and constants, and type custom attributes.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.BindTypes">
            <summary>
            Walks all expressions and resolves their access, operator method, and result CLR type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.SourceCompiler.LateStaticCallsLookup">
            <summary>
            Lookups self:: and parent:: static method calls.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.ForwardLateStaticBindings">
            <summary>
            Walks static methods that don't use late static binding and checks if it should forward the late static type;
            hence it must know the late static as well.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.SourceCompiler.EmitMethodBody(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Generates analyzed method.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Constants.CorSymLanguageTypePeachpie">
            <summary>
            PHP language Guid used by debugger.
            </summary>
            <remarks>Needs support in editor to show correct language name in call stack.</remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.Symbol">
            <summary>
            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.CheckDefinitionInvariant">
            <summary>
            Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.IsDefinitionOrDistinct">
            <summary>
            Return whether the symbol is either the original definition
            or distinct from the original. Intended for use in Debug.Assert
            only since it may include a deep comparison.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ContainingType">
            <summary>
            Returns the nearest lexically enclosing type, or null if there is none.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ContainingNamespace">
            <summary>
            Gets the nearest enclosing namespace for this namespace or type. For a nested type,
            returns the namespace that contains its container.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ContainingAssembly">
            <summary>
            Returns the assembly containing this symbol. If this symbol is shared across multiple
            assemblies, or doesn't belong to an assembly, returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.DeclaringCompilation">
            <summary>
            For a source assembly, the associated compilation.
            For any other assembly, null.
            For a source module, the DeclaringCompilation of the associated source assembly.
            For any other module, null.
            For any other symbol, the DeclaringCompilation of the associated module.
            </summary>
            <remarks>
            We're going through the containing module, rather than the containing assembly,
            because of /addmodule (symbols in such modules should return null).
            
            Remarks, not "ContainingCompilation" because it isn't transitive.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ContainingModule">
            <summary>
            Returns the module containing this symbol. If this symbol is shared across multiple
            modules, or doesn't belong to a module, returns null.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsDefinition">
            <summary>
            Returns true if this is the original definition of this symbol.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.DeclaringSyntaxReferences">
            <summary>
            <para>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for
            example, partial classes) may be defined in more than one location. This property should
            return one or more syntax nodes only if the symbol was declared in source code and also
            was not implicitly declared (see the <see cref="P:Pchp.CodeAnalysis.Symbol.IsImplicitlyDeclared"/> property). 
            </para>
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata or
            was implicitly declared, returns an empty read-only array.
            </returns>
            <remarks>
            To go the opposite direction (from syntax node to symbol), see <see
            cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns <see cref="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the <c>static</c> modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the <c>virtual</c> modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the <c>override</c> modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <remarks>
            Even for metadata symbols, <see cref="P:Pchp.CodeAnalysis.Symbol.IsOverride"/> = true does not imply that <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod"/> will
            be non-null.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the <c>abstract</c> modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the <c>sealed</c> modifier. Also set for
            types that do not allow a derived class (declared with <c>sealed</c> or <c>static</c> or <c>struct</c>
            or <c>enum</c> or <c>delegate</c>).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            <c>extern</c> modifier. 
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not
            have an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense,
            and may be used by code, but that are simply declared implicitly rather than
            with explicit language syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              the "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types,
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.IsUnreachable">
            <summary>
            Returns true if this symbol is declared in the source code, but this declaration is proven
            to be unreachable in execution. Symbols marked this way will not by emitted.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code. Examples of symbols
            that cannot be referenced by name are:
               constructors, destructors, operators, explicit interface implementations,
               accessor methods for properties and events, array types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.op_Equality(Pchp.CodeAnalysis.Symbol,Pchp.CodeAnalysis.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use <see cref="M:Pchp.CodeAnalysis.Symbol.op_Equality(Pchp.CodeAnalysis.Symbol,Pchp.CodeAnalysis.Symbol)"/> and <see cref="M:Pchp.CodeAnalysis.Symbol.op_Inequality(Pchp.CodeAnalysis.Symbol,Pchp.CodeAnalysis.Symbol)"/>, or the <see cref="M:Pchp.CodeAnalysis.Symbol.Equals(System.Object)"/> method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.op_Inequality(Pchp.CodeAnalysis.Symbol,Pchp.CodeAnalysis.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol, suitable for debugging purposes, or
            for placing in an error message.
            </summary>
            <remarks>
            This will provide a useful representation, but it would be clearer to call <see cref="M:Pchp.CodeAnalysis.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            directly and provide an explicit format.
            Sealed so that <see cref="M:Pchp.CodeAnalysis.Symbol.ToString"/> and <see cref="M:Pchp.CodeAnalysis.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/> can't get out of sync.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.Dangerous_IsFromSomeCompilation">
            <summary>
            Always prefer <see cref="M:Pchp.CodeAnalysis.Symbol.IsFromCompilation(Pchp.CodeAnalysis.PhpCompilation)"/>.
            </summary>
            <remarks>
            <para>
            Unfortunately, when determining overriding/hiding/implementation relationships, we don't 
            have the "current" compilation available.  We could, but that would clutter up the API 
            without providing much benefit.  As a compromise, we consider all compilations "current".
            </para>
            <para>
            Unlike in VB, we are not allowing retargeting symbols.  This method is used as an approximation
            for <see cref="M:Pchp.CodeAnalysis.Symbol.IsFromCompilation(Pchp.CodeAnalysis.PhpCompilation)"/> when a compilation is not available and that method will never return
            true for retargeting symbols.
            </para>
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.GetDocumentationCommentId">
            <summary>
            Returns the Documentation Comment ID for the symbol, or null if the symbol doesn't
            support documentation comments.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Fetches the documentation comment for this element with a cancellation token.
            </summary>
            <param name="preferredCulture">Optionally, retrieve the comments formatted for a particular culture. No impact on source documentation comments.</param>
            <param name="expandIncludes">Optionally, expand <![CDATA[<include>]]> elements. No impact on non-source documentation comments.</param>
            <param name="cancellationToken">Optionally, allow cancellation of documentation comment retrieval.</param>
            <returns>The XML that would be written to the documentation file for the symbol.</returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.HasUnsupportedMetadata">
            <summary>
            Indicates that this symbol uses metadata that cannot be supported by the language.
            
            Examples include:
               - Pointer types in VB
               - ByRef return type
               - Required custom modifiers
               
            This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
            Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
            
            This is set for metadata symbols, as follows:
            Type - if a type is unsupported (e.g., a pointer type, etc.)
            Method - parameter or return type is unsupported
            Field - type is unsupported
            Event - type is unsupported
            Property - type is unsupported
            Parameter - type is unsupported
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the <see cref="T:System.ObsoleteAttribute"/> attribute. 
            This property returns <see cref="F:Microsoft.CodeAnalysis.ThreeState.Unknown"/> if the <see cref="T:System.ObsoleteAttribute"/> attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Symbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from <see cref="T:System.ObsoleteAttribute"/> attribute or null if there is no <see cref="T:System.ObsoleteAttribute"/> attribute.
            This property returns <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.Uninitialized"/> if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Symbol.GetGuidStringDefaultImplementation(System.String@)">
            <summary>
            Returns true and a <see cref="T:System.String"/> from the first <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> on the symbol, 
            the string might be null or an invalid guid representation. False, 
            if there is no <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> with string argument.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Errors.ErrorCode">
            <summary>
            A database of all possible diagnostics used by PHP compiler. The severity can be determined by the prefix:
            "FTL_" stands for fatal error, "ERR_" for error, "WRN_" for warning, "INF_" for visible information and
            "HDN_" for hidden information. Messages and other information are stored in the resources,
            <see cref="T:Pchp.CodeAnalysis.Errors.ErrorFacts"/> contains the naming logic.
            </summary>
            <remarks>
            New diagnostics must be added to the end of the corresponding severity group in order not to change the
            codes of the current ones.
            </remarks>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_MethodCalledOnNonObject">
            <summary>Call to a member function {0} on {1}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ValueOfTypeCannotBeAliased">
            <summary>Value of type {0} cannot be passed by reference</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotInstantiateType">
            <summary>"Cannot instantiate {0} {1}", e.g. "interface", the type name</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotUseNonTrait">
            <summary>"{0} cannot use {1} - it is not a trait"</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotExtendFrom">
            <summary>"Class {0} cannot extend from {1} {2}", e.g. from trait T</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotImplementNonInterface">
            <summary>"{0} cannot implement {1} - it is not an interface"</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotAssignToThis">
            <summary>Cannot re-assign $this</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotDeclareReturnType">
            <summary>{0}() cannot declare a return type</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_VoidFunctionCannotReturnValue">
            <summary>A void function must not return a value</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_MustTakeArgs">
            <summary>{0} {1}() must take exactly {2} arguments</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_InvalidFunctionName">
            <summary>Function name must be a string, {0} given</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_FinalAbstractClassDeclared">
            <summary>Cannot use the final modifier on an abstract class</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_PropertyAccessibilityError">
            <summary>Access level to {0}::${1} must be {2} (as in class {3}) or weaker</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_PrimitiveTypeNameMisused">
            <summary>Use of primitive type '{0}' is misused</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_SwitchNeedsValue">
            <summary>Missing value for '{0}' option</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_NeedsLoopOrSwitch">
            <summary>'{0}' not in the 'loop' or 'switch' context</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_BadSourceCodeKind">
            <summary>Provided source code kind is unsupported or invalid: '{0}'</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_BadDocumentationMode">
            <summary>Provided documentation mode is unsupported or invalid: '{0}'.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_MutuallyExclusiveOptions">
            <summary>Compilation options '{0}' and '{1}' can't both be specified at the same time.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_InvalidInstrumentationKind">
            <summary>Invalid instrumentation kind: {0}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_InvalidHashAlgorithmName">
            <summary>Invalid hash algorithm name: '{0}'</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_OptionMustBeAbsolutePath">
            <summary>Option '{0}' must be an absolute path.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_EncodinglessSyntaxTree">
            <summary>Cannot emit debug information for a source text without encoding.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_PeWritingFailure">
            <summary>An error occurred while writing the output file: {0}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ModuleEmitFailure">
            <summary>Failed to emit module '{0}'.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_EncUpdateFailedMissingAttribute">
            <summary>Cannot update '{0}'; attribute '{1}' is missing.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_InvalidDebugInfo">
            <summary>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_BadAssemblyName">
            <summary>Invalid assembly name: {0}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_CannotEmbedWithoutPdb">
            <summary>/embed switch is only supported when emitting Portable PDB (/debug:portable or /debug:embedded).</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_NoMatchingOverload">
            <summary>No overload for method {0} can be called.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_DefaultParameterValueTypeMismatch">
            <summary>Default value for parameter ${0} with a {1} type can only be {1} or NULL, {2} given</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_InvalidConstantExpression">
            <summary>Constant expression contains invalid operations</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ThisOutOfObjectContext">
            <summary>Using $this when not in object context</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ReadOnlyPropertyWritten">
            <summary>Cannot set read-only property {0}::${1}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_VariadicParameterNotLast">
            <summary>Only the last parameter can be variadic</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_PropertyTypeNotAllowed">
            <summary>Property {0}::${1} cannot have type {2}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_MultipleAnalyzerConfigsInSameDir">
            <summary>Multiple analyzer config files cannot be in the same directory ('{0}').</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ArgumentTypeMismatch">
            <summary>Argument {0} passed to {1}() must be of the type {2}, {3} given</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_TypeMismatch">
            <summary>Cannot convert {0} to {1}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_NeverReturningFunctionCannotReturn">
            <summary>A never-returning function cannot return</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.ERR_ParameterTypeNotAllowed">
            <summary>Parameter ${0} cannot have type {1}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_AmbiguousDeclaration">
            <summary>The declaration of class, interface or trait is ambiguous since its base types cannot be resolved.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_TooManyArguments">
            <summary>{0}() expects {1} parameter(s), {2} given</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_MissingArguments">
            <summary>{0}() expects at least {1} parameter(s), {2} given</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_AssertAlwaysFail">
            <summary>Assertion will always fail</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_StringAssertionDeprecated">
            <summary>Using string as the assertion is deprecated</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_SymbolDeprecated">
            <summary>Deprecated: {0} '{1}' has been deprecated. {2}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ExpressionNotRead">
            <summary>The expression is not being read. Did you mean to assign it somewhere?</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_AssigningSameVariable">
            <summary>Assignment made to same variable; did you mean to assign something else?</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_InvalidArrayKeyType">
            <summary>Invalid array key type: {0}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_DuplicateArrayKey">
            <summary>Duplicate array key: '{0}'.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_CloneNonObject">
            <summary>Cloning of non-object: {0}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ForeachNonIterable">
            <summary>Using non-iterable type in foreach: {0}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_FormatStringWrongArgCount">
            <summary>Call to '{0}()' expects {1} argument(s), {2} given.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ParentCtorNotCalled">
            <summary>Missing the call of parent::__construct from {0}::__construct.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ParamPhpDocTypeHintIncompatible">
            <summary>PHPDoc type {0} of parameter ${1} is incompatible with its type hint {2}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_FieldPhpDocAssignIncompatible">
            <summary>Value of type {0} assigned to field {1} is incompatible with its PHPDoc type {2}.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ToStringMustReturnString">
            <summary>Method {0}::__toString() must return a string value</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_ArgumentVoid">
            <summary>Argument has no value, parameter will be always NULL</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_PCRE_Pattern_Error">
            <summary>PCRE pattern parse error: {0} at offset {1}</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_TypeNameInUse">
            <summary>{0} '{1}' is already defined</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_CannotIncludeFile">
            <summary>Script file '{0}' could not be resolved, the script inclusion is unbound.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_CalledFromGlobalScope">
            <summary>Called from the global scope</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_GeneratorFailedDuringInitialization">
            <summary>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_GeneratorFailedDuringGeneration">
            <summary>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.WRN_AttributeBindError">
            <summary>Couldn't bind attribute '{0}'. Either its arguments don't match any constructor or the type don't extend 'Attribute' class.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.INF_TypeNameCaseMismatch">
            <summary>Name '{0}' does not match the expected name '{1}', letter casing mismatch.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.INF_DestructDiscouraged">
            <summary></summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.INF_OverrideNameCaseMismatch">
            <summary>Overriden function name '{0}' does not match it's parent name '{1}', letter casing mismatch.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Errors.ErrorCode.INF_ConstantAlreadyDefined">
            <summary>Constant '{0}' with the same name is already defined</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Errors.ErrorFacts">
            <summary>
            Provides detailed information about compilation errors identified by <see cref="T:Pchp.CodeAnalysis.Errors.ErrorCode"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Errors.ErrorSink">
            <summary>
            Stores errors from PHP parser.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Errors.MessageProvider">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CommonMessageProvider"/> implementation for compilation errors stored in <see cref="T:Pchp.CodeAnalysis.Errors.ErrorCode"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Errors.ParserMessageProvider">
            <summary>
            This class stores a database of errors that can be thrown by Devsense PHP parser. It is populated dynamically -
            every time the parser throws an error, it must be registered in this class so that its details (such as format
            string) can be later retrieved.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.IsUnconditionalDeclaration(Pchp.CodeAnalysis.Symbols.IPhpRoutineSymbol)">
            <summary>
            Determines if given global function symbol is unconditionally declared (always declared).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.HandleSpecialFunctionCall``1(Pchp.CodeAnalysis.Semantics.BoundGlobalFunctionCall,Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis{``0},Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Resolves value of the function call in compile time if possible and updates the variable type if necessary
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.HandleTypeCheckingFunctions``1(Pchp.CodeAnalysis.Semantics.BoundGlobalFunctionCall,System.String,Pchp.CodeAnalysis.Semantics.BoundVariableRef,Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis{``0},Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Processes functions such as is_int, is_bool etc. Returns whether the function was one of these.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.HandleTypeCheckingExpression(Pchp.CodeAnalysis.Semantics.BoundVariableRef,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch,Pchp.CodeAnalysis.FlowAnalysis.FlowState,System.Boolean,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean)">
            <summary>
            Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
            branch. If the current branch is unfeasible, assigns an appropriate boolean to the
            <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
            </summary>
            <param name="varRef">The reference to the variable whose types to check.</param>
            <param name="targetType">The target type of the variable.</param>
            <param name="branch">The branch to check - <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch.ToTrue"/> is understood as the positive
            branch if <paramref name="isPositiveCheck"/> is true.</param>
            <param name="flowState">The flow state of the branch.</param>
            <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsAnyType"/> in the
            positive branch (in the negative branch, it is always skipped).</param>
            <param name="checkExpr">The expression to have its <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ConstantValue"/> potentially
            updated.</param>
            <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
            in the case of != it would be false.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.HandleTypeCheckingExpression(Pchp.CodeAnalysis.Semantics.BoundVariableRef,System.Func{Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask},Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch,Pchp.CodeAnalysis.FlowAnalysis.FlowState,System.Boolean,Pchp.CodeAnalysis.Semantics.BoundExpression,System.Boolean)">
            <summary>
            Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
            branch. If the current branch is unfeasible, assigns an appropriate boolean to the
            <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
            </summary>
            <param name="varRef">The reference to the variable whose types to check.</param>
            <param name="targetTypeCallback">The callback that receives the current type mask of the variable and returns
            the target one.</param>
            <param name="branch">The branch to check - <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch.ToTrue"/> is understood as the positive
            branch if <paramref name="isPositiveCheck"/> is true.</param>
            <param name="flowState">The flow state of the branch.</param>
            <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsAnyType"/> in the
            positive branch (in the negative branch, it is always skipped).</param>
            <param name="checkExpr">The expression to have its <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.ConstantValue"/> potentially
            updated.</param>
            <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
            in the case of != it would be false.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.IsValidKeyType(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Returns whether the given type can be used as an array key.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisFacts.TryGetCanonicKeyStringConstant(Microsoft.CodeAnalysis.Optional{System.Object},System.ValueTuple{System.String,System.Int64}@)">
            <summary>
            If present, transforms the given constant value to a string corresponding to the key under which the item is stored in an array.
            </summary>
            <param name="keyConst">Constant value of the key.</param>
            <param name="key">If <paramref name="keyConst"/> contains a value, the key as a (string, long) tuple.
            The second item should be taken into account only if the first one is null.</param>
            <returns>Whether the value was constant at all.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.AnalysisFlags">
            <summary>
            Analysis progress flags.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.AnalysisFlags.IsCanceled">
            <summary>
            The analysis has been canceled since internal state has changed.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.State">
            <summary>
            Current flow state.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.CurrentBlock">
            <summary>
            Gets reference to current block.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2._flags">
            <summary>
            Gathered analysis progress.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.AssertState">
            <summary>
            Debug assert the state is initialized therefore we are in the middle on a block analysis.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.TraverseToBlock(System.Object,`0,Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Helper method that merges state with the target block and determines whether to continue by visiting the target block.
            </summary>
            <param name="edgeLabel">Label identifying incoming edge.</param>
            <param name="state">Locals state in which we are entering the target.</param>
            <param name="target">Target block.</param>
            <remarks>Only for traversing into blocks within the same routine (same type context).</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.VisitCFGBlockInit(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)">
            <summary>
            Called to initialize <see cref="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.VisitCFGBlock(Pchp.CodeAnalysis.Semantics.Graph.BoundBlock)"/> call.
            Sets <see cref="P:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.State"/> to known initial block state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.Visit(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundAccess)">
            <summary>
            Updates the expression access and visits it.
            </summary>
            <param name="x">The expression.</param>
            <param name="access">New access.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.VisitCondition(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Visits condition used to branch execution to true or false branch.
            </summary>
            <returns>Value indicating whether branch was used.</returns>
            <remarks>
            Because of minimal evaluation there is different state for true and false branches,
            AND and OR operators have to take this into account.
            
            Also some other constructs may have side-effect for known branch,
            eg. <c>($x instanceof X)</c> implies ($x is X) in True branch.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.AnalysisWalker`2.HandleTraversableUse(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Handles use of variable as foreach iterator value.
            </summary>
            <param name="varuse"></param>
            <returns>Derivate type of iterated values.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch">
            <summary>
            Whether the expression is evaluated as a part of branch condition.
            May have side effect of minimal evaluation (short-circuit evaluation) to current _state.
            Affects <c>&amp;&amp;</c> and <c>||</c> operators, optionally other conditions that might infer more information to true or false branch.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranchEnum">
            <summary>
            Helper methods for <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranchEnum.NegativeBranch(Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Switches <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch.ToTrue"/> and <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch.ToFalse"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranchEnum.TargetValue(Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Gets the boolean value of the condition that led to this branch or null if
            <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch.AnyResult"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1">
            <summary>
            Visits single expressions and project transformations to flow state.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.Worklist">
            <summary>
            The worklist to be used to enqueue next blocks.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.Model">
            <summary>
            Gets model for symbols resolution.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.Routine">
            <summary>
            Reference to corresponding source routine.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.TypeCtx">
            <summary>
            Gets current type context for type masks resolving.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.TryGetVariableHandle(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            In case given expression is a local or parameter reference,
            gets its variable handle within <see cref="T:Devsense.PHP.Syntax.State"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.AsVariableName(Pchp.CodeAnalysis.Semantics.BoundReferenceExpression)">
            <summary>
            In case of a local variable or parameter, gets its name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.TryGetExpressionChainRoot(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Finds the root of given chain, i.e.:
            $a : $a
            $$a : $a
            $a->b : $a
            $a[..] : $a
            $a->foo() : $a
            etc.
            </summary>
            <remarks>If given expression 'isset', its root returned by this method must be set as well.</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.VisibilityScope">
            <summary>
            Gets current visibility scope.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsDoubleOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents a double and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsDoubleOnly(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets value indicating the given type represents a double and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsLongOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents a long and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsLongOnly(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets value indicating the given type represents a long and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsNumberOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type is long or double or both but nothing else.
            </summary>
            <param name="tmask"></param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsClassOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents only class types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsArrayOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type represents only array types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.IsNumberOnly(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets value indicating the given type is long or double or both but nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.#ctor(Pchp.CodeAnalysis.FlowAnalysis.Worklist{Pchp.CodeAnalysis.Semantics.Graph.BoundBlock},Pchp.CodeAnalysis.Semantics.ISymbolProvider)">
            <summary>
            Creates an instance of <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1"/> that can analyse a block.
            </summary>
            <param name="worklist">The worklist to be used to enqueue next blocks.</param>
            <param name="model">The semantic context of the compilation.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.GetBitOperationType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets resulting type of bit operation (bit or, and, xor).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.ResolveBitOperation(Microsoft.CodeAnalysis.Optional{System.Object},Microsoft.CodeAnalysis.Optional{System.Object},Devsense.PHP.Syntax.Ast.Operations)">
            <summary>
            Resolves value of bit operation.
            </summary>
            <remarks>TODO: move to **evaluation**.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.GetPlusOperationType(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets resulting type of <c>+</c> operation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.GetMinusOperationType(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets resulting type of <c>-</c> operation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.ResolveComparison(Devsense.PHP.Syntax.Ast.Operations,System.Object,System.Object)">
            <summary>
            If possible, resolve the comparison operation in compile-time.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.ResolveEqualityWithConstantValue(Pchp.CodeAnalysis.Semantics.BoundBinaryEx,Pchp.CodeAnalysis.Semantics.BoundReferenceExpression,Microsoft.CodeAnalysis.Optional{System.Object},Pchp.CodeAnalysis.FlowAnalysis.ConditionBranch)">
            <summary>
            Resolves variable types and potentially assigns a constant boolean value to an expression of a comparison of
            a variable and a constant - operators ==, !=, === and !==. Returns true iff this expression was handled and there
            is no need to analyse it any more (adding constant value etc.).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.ResolveEquality(Pchp.CodeAnalysis.Semantics.BoundBinaryEx)">
            <summary>
            Attempts to infer the result of an equality comparison from the types of the operands.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.ExpressionAnalysis`1.BindRoutineCall(Pchp.CodeAnalysis.Semantics.BoundRoutineCall,System.Boolean)">
            <summary>
            Bind arguments to target method and resolve resulting <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.TypeRefMask"/>.
            Expecting <see cref="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.TargetMethod"/> is resolved.
            If the target method cannot be bound at compile time, <see cref="P:Pchp.CodeAnalysis.Semantics.BoundRoutineCall.TargetMethod"/> is nulled.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.FlowContext">
            <summary>
            Manages context of local variables, their merged type and return value type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.BitsCount">
            <summary>
            Size of ulong bit array (<c>64</c>).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.TypeRefContext">
            <summary>
            Associated type context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.Routine">
            <summary>
            Reference to corresponding routine symbol. Can be a <c>null</c> reference.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.ContainingFile">
            <summary>
            Gets reference to containing file symbol.
            Cannot be <c>null</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowContext._varsIndex">
            <summary>
            Map of variables name and their index.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowContext._usedMask">
            <summary>
            Bit mask of variables where bit with value <c>1</c> signalizes that variables with index corresponding to the bit number has been used.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.VarsType">
            <summary>
            Merged local variables type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.ReturnType">
            <summary>
            Merged return expressions type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.Version">
            <summary>
            Version of the analysis, incremented whenever a set of semantic tree transformations happen.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.GetVarIndex(Devsense.PHP.Syntax.VariableName)">
            <summary>
            Gets index of variable within the context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.EnumerateVariables">
            <summary>
            Enumerates all known variables as pairs of their index and name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.IsReference(System.Int32)">
            <summary>
            Gets value indicating whether given variable might be a reference.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.SetUsed(System.Int32)">
            <summary>
            Sets specified variable as being used.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.SetAllUsed">
            <summary>
            Marks all local variables as used.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowContext.InvalidateAnalysis">
            <summary>
            Discard the current flow analysis information, should be called whenever the routine is transformed.
            </summary>
            <remarks>
            It is expected to be called either on a context without a routine (parameter initializers etc.) or
            on a routine with a CFG, hence no abstract methods etc.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowState.FlowContext">
            <summary>
            Gets flow context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowState.TypeRefContext">
            <summary>
            Gets type context.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowState.Routine">
            <summary>
            Source routine.
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowState._varsType">
            <summary>
            Types of variables in this state.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowState._initializedMask">
            <summary>
            Mask of initialized variables in this state.
            </summary>
            <remarks>
            Single bits indicates the corresponding variable was set.
            <c>0</c> determines the variable was not set in any code path.
            <c>1</c> determines the variable may be set.
            </remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.FlowState.Version">
            <summary>
            Version of the analysis this state was created for.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.#ctor(Pchp.CodeAnalysis.FlowAnalysis.FlowState,Pchp.CodeAnalysis.FlowAnalysis.FlowState)">
            <summary>
            Merge constructor.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.#ctor(Pchp.CodeAnalysis.FlowAnalysis.FlowContext)">
            <summary>
            Initial locals state for the Start block.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.#ctor(Pchp.CodeAnalysis.FlowAnalysis.FlowState)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.#ctor(Pchp.CodeAnalysis.FlowAnalysis.FlowContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask[])">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.Clone">
            <summary>
            Creates copy of this state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.Merge(Pchp.CodeAnalysis.FlowAnalysis.FlowState)">
            <summary>
            Creates new state as a merge of this one and the other.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.GetLocalHandle(Devsense.PHP.Syntax.VariableName)">
            <summary>
            Gets variable handle use for other variable operations.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetLocalType(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Sets variable type in this state.
            </summary>
            <param name="handle">Variable handle.</param>
            <param name="tmask">Variable type. If <c>uninitialized</c>, the variable is set as not initialized in this state.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetLocalRef(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Sets variable type with byref flag in this state.
            </summary>
            <param name="handle">Variable handle.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.GetLocalType(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets type of variable at this state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.MarkLocalByRef(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Marks variable as being referenced.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.VisitLocal(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Handles use of a local variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetAllUnknown(System.Boolean)">
            <summary>
            Sets all variables as initialized at this state and with a <c>mixed</c> type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.IsLocalSet(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets value indicating the variable may be set in some code paths.
            Gets also <c>true</c> if we don't known.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowState.NoteKind.LessThanLongMax">
            <summary>
            Noting that variable is less than Long.Max.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.FlowState.NoteKind.GreaterThanLongMin">
            <summary>
            Noting that variable is greater than Long.Min.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetLessThanLongMax(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle,System.Boolean)">
            <summary>
            Sets or removes LTInt64 flag for a variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.IsLessThanLongMax(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets LTInt64 flag for a variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetGreaterThanLongMin(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle,System.Boolean)">
            <summary>
            Sets or removes GTInt64 flag for a variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.IsGreaterThanLongMin(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets GTInt64 flag for a variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.GetReturnType">
            <summary>
            Gets merged return value type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.SetVarKind(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle,Pchp.CodeAnalysis.Symbols.VariableKind)">
            <summary>
            Declares variable with a specific kind (static or global).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.FlowState.MergeType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Merges given types coming from two flows.
            Uninitialized value (<c>0L</c>) is treated as <c>NULL</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.Clone">
            <summary>
            Creates copy of this state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.Merge(`0)">
            <summary>
            Creates new state as a merge of this one and the other.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.GetLocalHandle(Devsense.PHP.Syntax.VariableName)">
            <summary>
            Gets variable handle use for other variable operations.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.SetLocalType(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Sets variable type in this state.
            </summary>
            <param name="handle">Variable handle.</param>
            <param name="tmask">Variable type. If <c>void</c> or <c>uninitialized</c>, the variable is set as not initialized in this state.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.GetLocalType(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets type of variable at this state.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.MarkLocalByRef(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Marks variable as being referenced.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.VisitLocal(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Handles use of a local variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.SetAllUnknown(System.Boolean)">
            <summary>
            Sets all variables as initialized at this state and with a <c>mixed</c> type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.IsLocalSet(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)">
            <summary>
            Gets value indicating the variable is set in all code paths.
            Gets also <c>true</c> if we don't known.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.IFlowState`1.FlowThroughReturn(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Records return value type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle">
            <summary>
            Represents a variable in the routine context.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle._index">
            <summary>
            Valid indexes starts from <c>1</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle._name">
            <summary>
            The variable name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle.IsValid">
            <summary>
            Gets value indicating the handle is valid.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle.ThrowIfInvalid">
            <summary>
            throws an exception if the handle is not valid.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle.Slot">
            <summary>
            Gets or sets internal slot within the locals variable table starting from <c>0</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle.Name">
            <summary>
            The variable name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.VariableHandle.op_Implicit(Pchp.CodeAnalysis.FlowAnalysis.VariableHandle)~System.Int32">
            <summary>
            Implicitly converts the handle to an integer slot index.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.DelayedTransformations">
            <summary>
            Stores certain types of transformations in parallel fashion and performs them serially afterwards.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.Passes.DelayedTransformations.UnreachableRoutines">
            <summary>
            Routines with unreachable declarations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.Passes.DelayedTransformations.UnreachableTypes">
            <summary>
            Types with unreachable declarations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.Passes.DelayedTransformations.FunctionsMarkedAsUnconditional">
            <summary>
            Functions that were declared conditionally but analysis marked them as unconditional.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Passes.DiagnosticWalker`1.HasBaseConstruct(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Checks the base class has implementation of `__construct` which should be called.
            </summary>
            <param name="type">Self.</param>
            <returns>Whether the base of <paramref name="type"/> has `__construct` method implementation.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Passes.DiagnosticWalker`1.IsLetterCasingMismatch(System.String,System.String)">
            <summary>
            Determines if both identifiers differ only in casing.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.DiagnosticWalker`1.s_printfSpecsRegex">
            <summary>
            Matches <c>printf()</c> format specifier.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.ResultTypeBinder">
            <summary>
            Walks all expressions and resolves their access, operator method, and result CLR type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Passes.ResultTypeBinder.BindAccess(Pchp.CodeAnalysis.Semantics.BoundExpression,Pchp.CodeAnalysis.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Resolves access operator and updates <see cref="P:Pchp.CodeAnalysis.Semantics.BoundExpression.BoundConversion"/>.
            </summary>
            <param name="expression">The expression which access has to be resolved.</param>
            <param name="type">The value type.</param>
            <param name="hasref">Whether we have the value by ref (addr).</param>
            <returns>Resulting expression type.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.CopyAnalysisState">
            <summary>
            Each state in copy analysis maps each variable to a set of <see cref="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue"/> instances.
            Whenever a variable is modified, all the mapped copy operations are considered unavailable for removal
            due to the possible aliasing.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.CopyAnalysis">
            <summary>
            Implements copy analysis using <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.CopyAnalysisState"/>, producing a set of <see cref="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue"/>
            instances available for removal.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.CopyAnalysis._lazyReturnCopies">
            <summary>
            Set of <see cref="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue"/> instances located in return statements, to be filtered in the exit node.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.CopyAnalysis.Add``2(``0@,``1)">
            <summary>
            Adds the value to lazily initialized set.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter._special_functions">
            <summary>
            Map of well-known routines and corresponding rewrite rule that can return a new expression as a replacement for the routine call.
            Return <c>null</c> if the routine was not rewritten.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.MatchExprSkipCopy``1(Pchp.CodeAnalysis.Semantics.BoundExpression,``0@,System.Boolean@)">
            <summary>
            If <paramref name="expr"/> is of type <typeparamref name="T"/> or it is a <see cref="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue" /> enclosing an
            expression of type <typeparamref name="T"/>, store the expression to <paramref name="typedExpr"/> and return true;
            otherwise, return false. Store to <paramref name="isCopied"/> whether <paramref name="typedExpr"/> was enclosed in
            <see cref="T:Pchp.CodeAnalysis.Semantics.BoundCopyValue"/>.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysisState">
            <summary>
            The state denotes whether a potential modification of any parameter containing alias could have
            happened (e.g. by calling an external method).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysisState.Unexplored">
            <summary>
            We haven't analysed this code.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysisState.Clean">
            <summary>
            We have already analysed this code and haven't discovered any operation possibly modifying any alias
            outside the routine scope.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysisState.Dirty">
            <summary>
            Any parameter dereference encountered in this state on prevents its value passing from being skipped, because
            a possible alias modification might have happened.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysis">
            <summary>
            Implements parameter value passing analysis using <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysisState"/>, retrieving information
            about on which parameters we don't need to call PassValue.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Passes.TransformationRewriter.ParameterAnalysis._needPassValueParams">
            <summary>
            Records parameters which need to be deep copied and dealiased upon routine start.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.PHPDoc">
            <summary>
            Helpers class for resolving PHPDoc types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.PHPDoc.GetParamTag(Devsense.PHP.Syntax.PHPDocBlock,System.Int32,System.String)">
            <summary>
            Gets parameter type from given PHPDoc block.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags">
            <summary>
            Flags describing special routine needs.
            Collected during flow analysis.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.UsesLateStatic">
            <summary>
            The routine uses <c>static::</c> construct to access late static bound type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.HasUserFunctionCall">
            <summary>
            Indicates the routine contains function calls.
            This can be used for analysis heuristics.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.IsUnreachable">
            <summary>
            Indicates that the routine declaration was proven unreachable during the analysis.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.MarkedDeclaredUnconditionally">
            <summary>The global function has been declared conditionally but analysis marked it as unconditional.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.IsReturnAnalysed">
            <summary>
            Internal. Marks whether the exit block or any block with a return statement was already processed at least once.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.RequiresLocalsArray">
            <summary>
            Whether the routine has to define local variables as an array instead of native local variables.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.RoutineFlags.RequiresVarArg">
            <summary>
            Whether the routine accesses its arguments dynamically we should provide params.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.StateBinder">
            <summary>
            Binds flow state to a routine.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.StateBinder.CreateInitialState(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol,Pchp.CodeAnalysis.FlowAnalysis.FlowContext)">
            <summary>
            Creates new type context, flow context and flow state for the routine.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.StateBinder.InitThisVar(Pchp.CodeAnalysis.FlowAnalysis.FlowContext,Pchp.CodeAnalysis.FlowAnalysis.FlowState)">
            <summary>
            Initializes <c>$this</c> variable, its type and initialized state.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.CallInfo">
            <summary>
            Used by analysis of routine in case we know additional information about called context.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.CallInfo._typeCtx">
            <summary>
            Context of type references used in call info.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.CallInfo._paramsType">
            <summary>
            Known types of parameters.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.CallInfo._lateStaticBindType">
            <summary>
            Optional. Gets type of <c>static</c> in called context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.#ctor(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,System.Int32)">
            <summary>
            Initializes <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.CallInfo"/>.
            </summary>
            <param name="ctx">Type context of the caller.</param>
            <param name="paramsCount">Amount of parameters used for the call.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.#ctor(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,System.Int32,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Initializes <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.CallInfo"/>.
            </summary>
            <param name="ctx">Type context of the caller.</param>
            <param name="paramsCount">Amount of parameters used for the call.</param>
            <param name="lateStaticBindType">Type of the <c>self</c> in the caller context.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.#ctor(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask[])">
            <summary>
            Initializes <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.CallInfo"/>.
            </summary>
            <param name="ctx">Type context of the caller.</param>
            <param name="paramsType">Type of parameters used for the call. Length of the array corresponds to the parameters count.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.#ctor(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask[],Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Initializes <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.CallInfo"/>.
            </summary>
            <param name="ctx">Type context of the caller.</param>
            <param name="paramsType">Type of parameters used for the call. Length of the array corresponds to the parameters count.</param>
            <param name="lateStaticBindType">Type of the <c>self</c> in the caller context.</param>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.ParametersCount">
            <summary>
            Gets known parameters count. If call info is empty, the method gets <c>-1</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.GetParamType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,System.Int32)">
            <summary>
            Gets actual parameter type if provided. Otherwise <c>void</c>.
            </summary>
            <param name="ctx">Target type context.</param>
            <param name="index">Index of parameter.</param>
            <returns>Type mask of the parameter or <c>void</c>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.CallInfo.GetLateStaticBindType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Gets actual lates static bind type (type of <c>static</c>) if provided.
            Otherwise <c>void</c>.
            </summary>
            <param name="ctx">Target type context.</param>
            <returns>TYpe mask of <c>static</c> in given context or <c>void</c>.</returns>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode">
            <summary>
            Compatible PHP type codes.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Undefined">
            <summary>
            An invalid value, <c>void</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Void">
            <summary>
            An invalid value, <c>void</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Boolean">
            <summary>
            The value is of type boolean.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Long">
            <summary>
            64-bit integer value.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Double">
            <summary>
            64-bit floating point number.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.String">
            <summary>
            Unicode string value. Two-byte (UTF16) readonly string.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.WritableString">
            <summary>
            Both Unicode and Binary writable string value. Encapsulates two-byte (UTF16), single-byte (binary) string and string builder.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.PhpArray">
            <summary>
            A PHP array.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Object">
            <summary>
            A class type, including <c>NULL</c>, <c>Closure</c> or a generic <c>Object</c>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Resource">
            <summary>
            A PHP resource.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Iterable">
            <summary>
            An iterable object (array, Traversable).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Callable">
            <summary>
            Callable type (array(2), string, object).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Null">
            <summary>
            Object that might be <c>NULL</c>.
            Used in combination with <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Object"/> (?).
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.PhpTypeCode.Mixed">
            <summary>
            Any type, used for compatibility with <c>mixed</c> primitive type.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers">
            <summary>
            Provides helper methods for working with types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.IsNumber(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Determines if given <see cref="T:Pchp.CodeAnalysis.Semantics.IBoundTypeRef"/> represents a number (integral or real).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.IsCallable(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Checks whether given type may be callable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.HasArrayAccess(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.PhpCompilation)">
            <summary>
            Gets value indicating whether specified object of type <paramref name="type"/> handles <c>[]</c> operator.
            In case of ambiguity, all ambiguities must support the array access operator.
            </summary>
            <param name="type">Type of the object.</param>
            <param name="ctx">Type context.</param>
            <param name="compilation">Type provider.</param>
            <returns>True iff <c>[]</c> operator is allowed.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.IsVoid(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Checks the given type mask represents <c>void</c>.
            It may be zero mask (no types) or specifically "void" primitive type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.IsLongOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type mask represents LONG only and nothing else.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeHelpers.IsDoubleOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the given type mask represents DOUBLE only and nothing else.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext">
            <summary>
            Context of <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask"/> and <see cref="T:Pchp.CodeAnalysis.Semantics.IBoundTypeRef"/> instances.
            Contains additional information for routine context like current namespace, current type context etc.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable">
            <summary>
            Fast enumerable of types within <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/> denotated by a bit mask.
            No allocations.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.FirstOrDefault">
            <summary>
            Gets the first element in the enumeration or <c>null</c> if the enumeration is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.IsEmpty">
            <summary>
            Gets value indicating the enumation is empty;
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.IsSingle">
            <summary>
            Gets value indicating there is just one item.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.Count">
            <summary>
            Gets items count.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.Select``1(System.Func{Pchp.CodeAnalysis.Semantics.IBoundTypeRef,``0})">
            <summary>
            Creates array and selects items into it.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.Any">
            <summary>
            Gets value indicating the collection is not empty.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.Any(System.Func{Pchp.CodeAnalysis.Semantics.IBoundTypeRef,System.Boolean})">
            <summary>
            Gets value indicating an item in this collection is valid for given <paramref name="predicate"/>.
            </summary>
            <param name="predicate">Predicate. Cannot be <c>null</c>.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.AllIsArray">
            <summary>
            Enumeration is empty or all items are <see cref="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsArray"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.AllIsNumber">
            <summary>
            Enumeration is empty or all items are a number.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.AllIsObject">
            <summary>
            Enumeration is empty or all items are <see cref="P:Pchp.CodeAnalysis.Semantics.IBoundTypeRef.IsObject"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerable.All(System.Func{Pchp.CodeAnalysis.Semantics.IBoundTypeRef,System.Boolean})">
            <summary>
            Determines whether all elements of a sequence satisfy a condition.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerator">
            <summary>
            Fast enumerator of types within <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/> denotated by a bit mask.
            No allocations.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerator.Current">
            <summary>
            Gets the current item.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.TypeRefEnumerator.MoveNext">
            <summary>
            Moves to the next item.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isNullMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isObjectMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isArrayMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isLongMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isDoubleMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isBoolMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isStringMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isWritableStringMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._isLambdaMask">
            <summary>
            Bit masks initialized when such type is added to the context.
            Its bits corresponds to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs"/> indices.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._typeRefs">
            <summary>
            List of types occuring in the context.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._compilation">
            <summary>Corresponding compilation object. Cannot be <c>null</c>.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.SelfType">
            <summary>
            Contains type of current context (refers to <c>self</c>).
            Can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.ThisType">
            <summary>
            Type corresponding to <c>$this</c> variable.
            Can be <c>null</c> if <c>$this</c> is resolved in runtime.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext._staticTypeMask">
            <summary>
            When resolved, contains type mask of <c>static</c> type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.SetLateStaticBindType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Explicitly defines late static bind type (type of <c>static</c>).
            </summary>
            <param name="staticTypeMask">Type mask of <c>static</c> or <c>void</c> if this information is unknown.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.AddToContext(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Ensures given type is in the context.
            </summary>
            <param name="typeRef">Type reference to be in the context.</param>
            <returns>Index of the type within the context. Can return <c>-1</c> if there is too many types in the context already.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.UpdateMasks(Pchp.CodeAnalysis.Semantics.IBoundTypeRef,System.Int32)">
            <summary>
            Updates internal masks for newly added type.
            </summary>
            <param name="typeRef">Type.</param>
            <param name="index">Type index.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.AddToContext(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext)">
            <summary>
            Adds properly types from another context.
            </summary>
            <param name="other">Another type context which types will be added to this one.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.AddToContext(Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Adds properly types from another context matching given mask.
            </summary>
            <param name="context">Context of <paramref name="mask"/>.</param>
            <param name="mask">Type mask representing types in <paramref name="context"/>.</param>
            <returns>Returns type mask in this context representing <paramref name="mask"/> as <paramref name="context"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetTypes(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,System.UInt64)">
            <summary>
            Gets enumeration of types matching given masks.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetPrimitiveTypeRefMaskNoCheck(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Does not lookup existing types whether there is typeref already.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetTypeMask(Pchp.CodeAnalysis.Semantics.IBoundTypeRef,System.Boolean)">
            <summary>
            Helper method that builds <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask"/> for given type in this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetTypeMaskFromLiteral(Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Resolves type mask corresponding to given compile time value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetSystemObjectTypeMask">
            <summary>
            Gets type mask corresponding to <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetNullTypeMask">
            <summary>
            Gets type mask corresponding to <c>NULL</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetStringTypeMask">
            <summary>
            Gets <c>string</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetWritableStringTypeMask">
            <summary>
            Gets PHP <c>string</c> type (a string builder for 8bit and UTF characters) for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetLongTypeMask">
            <summary>
            Gets <c>int</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetBooleanTypeMask">
            <summary>
            Gets <c>bool</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetDoubleTypeMask">
            <summary>
            Gets <c>double</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetNumberTypeMask">
            <summary>
            Gets <c>number</c> (<c>int</c> and <c>double</c>) type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetResourceTypeMask">
            <summary>
            Gets type mask of a resource type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetClosureTypeMask">
            <summary>
            Gets type mask of a closure.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetCallableTypeMask">
            <summary>
            Gets type mask of all callable types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetArrayTypeMask">
            <summary>
            Gets type mask of generic <c>array</c> with element of any type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetArrayTypeMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets type mask of <c>array</c> with elements of given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetSelfTypeMask">
            <summary>
            Gets <c>self</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetThisTypeMask">
            <summary>
            Gets type of <c>$this</c> in current context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetParentTypeMask">
            <summary>
            Gets <c>parent</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetStaticTypeMask">
            <summary>
            Gets <c>static</c> type for this context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetArraysFromMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets mask representing only array types in given mask.
            (Only bits corresponding to an array type will be set).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetObjectsFromMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets mask representing only object types in given mask.
            (Only bits corresponding to an object type will be set).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetLambdasFromMask(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets mask representing only lambda types in given mask.
            (Only bits corresponding to a lambda type will be set).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.Types">
            <summary>
            Gets enumeration of all types in the context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetTypes(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets types referenced by given type mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetObjectTypes(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets types of type <c>object</c> (classes, interfaces, traits) referenced by given type mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.ToString(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets string representation of types contained in given type mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetTypeIndex(Pchp.CodeAnalysis.Semantics.IBoundTypeRef)">
            <summary>
            Gets index of the given type within the context. Returns <c>-1</c> if such type is not present.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsNumber(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a number.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsNull(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the type represents <c>NULL</c> (not <c>mixed</c>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsNullOrVoid(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating the type represents <c>NULL</c> or <c>void</c> (not <c>mixed</c>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsAString(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a string type (readonly or writable).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsReadonlyString(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents UTF16 readonly string.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsWritableString(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a writablke string (string builder).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsBoolean(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a boolean.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsLong(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents an integer type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsDouble(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a double type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsObject(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents an object.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsObjectOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents only object(s).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsArray(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents an array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsArrayOnly(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents only array(s).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsLambda(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type mask represents a lambda function or <c>callable</c> primitive type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.IsNullable(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Gets value indicating whether given type can be <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.GetElementType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            In case of array type, gets its possible element types.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.WithoutNull(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Remove <c>NULL</c> type from the given mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext.CanBeSameType(Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask,Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask)">
            <summary>
            Returns whether there exists a type present possibly in both <paramref name="a"/> and <paramref name="b"/>.
            The result is overapproximate - false result is ensured to be sound, but true result means it is possible
            but not certain (e.g. class hierarchy is not checked for object and array type compatibility).
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask">
            <summary>
            Represents type mask for <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IndicesCount">
            <summary>
            Gets maximum number of types that can be handled by <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.FlagsMask">
            <summary>
            Bit mask of all flags supported by the <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.AnyTypeMask">
            <summary>
            Mask of any type.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsRefMask">
            <summary>
            Mask of an aliased value.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.MaskFlags">
            <summary>
            Additional type mask flags.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.MaskFlags.IsRef">
            <summary>
            Denotates a value that might be referenced.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.MaskFlags.IncludesSubclasses">
            <summary>
            Denotates a type that might include its subtypes as well.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.MaskFlags.Mask">
            <summary>
            Mask of all flags.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.Mask">
            <summary>
            Each bit corresponds to a type within its <see cref="T:Pchp.CodeAnalysis.FlowAnalysis.TypeRefContext"/>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.Flags">
            <summary>
            Gets the type mask flags part only.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsAnyType">
            <summary>
            Gets value indicating whether the type represents an any type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsUninitialized">
            <summary>
            Gets value indicating whether the type information is not initialized.
            </summary>
            <remarks>Also represents <c>void</c> type.</remarks>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsDefault">
            <summary>
            Gets value indicating whether the type information is not initialized.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsVoid">
            <summary>
            Gets value indicating whether the type represents <c>void</c>.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsRef">
            <summary>
            Gets or sets value indicating whether the type might represent an alias.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.WithRefFlag">
            <summary>
            Gets copy of this type mask with the reference flag.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.WithoutRefFlag">
            <summary>
            Gets copy of this type mask without the reference flag.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.WithSubclasses">
            <summary>
            Gets copy of this type mask with the including subclasses flag.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.WithoutSubclasses">
            <summary>
            Gets copy of this type mask with the including subclasses flag.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.TypesMask">
            <summary>
            Gets bits corresponding to types only, excluding flags.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IncludesSubclasses">
            <summary>
            Gets value indicating whether given type mask represents a type including its subclasses.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IsSingleType">
            <summary>
            Gets value indicating whether the mask represents just a single type reference.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.AnyType">
            <summary>
            Gets type mask representing any type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.CreateFromTypeIndex(System.Int32)">
            <summary>
            Creates type mask corresponding to a single type of given index.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.HasType(System.Int32)">
            <summary>
            Gets value indicating whether this type mask represents the type with given index.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.AddType(System.Int32)">
            <summary>
            Adds type with given index to the mask.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.SetIsRef">
            <summary>
            Marks this as an aliased value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.RemoveIsRef">
            <summary>
            Marks this as not an aliased value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.SetIncludesSubclasses">
            <summary>
            Marks this type as it may include subclasses.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.RemoveIncludesSubclasses">
            <summary>
            Marks this type as is does not include subclasses.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.Item(System.Int32)">
            <summary>
            Gets or sets value indicating whether the mask represents a type at given index.
            </summary>
            <remarks>Index higher than or equal to <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.TypeRefMask.IndicesCount"/> are ignored.</remarks>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1">
            <summary>
            Queue of work items to do.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1.AnalyzeBlockDelegate">
            <summary>
            Delegate used to process <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1._analyzers">
            <summary>
            Action performed on bound operations.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1._queue">
            <summary>
            List of blocks to be processed.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1._dirtyCallBlocks">
            <summary>
            Set of blocks that need to be processed, but the methods they call haven't been processed yet.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1._currentRoutinesLastReturnTypes">
            <summary>
            In the case of updating an existing analysis, a map of the currently analysed routines to their previous return types.
            Null in the case of a fresh analysis.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1.Enqueue(`0)">
            <summary>
            Adds block to the queue.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1.DoAll(System.Boolean)">
            <summary>
            Processes all tasks until the queue is not empty.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1.Update(System.Collections.Generic.IEnumerable{Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol},System.Boolean)">
            <summary>
            Re-run the analysis for the specified routines. Repeatively propagate the changes of their return types
            to their callers, until there are none left.
            </summary>
            <remarks>
            It is expected that the introduced changes don't change the semantics of the program and hence don't
            increase the set of possible return types of the particular routines.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1.Dequeue(`0[])">
            <summary>
            Fills the given array with dequeued blocks from <see cref="F:Pchp.CodeAnalysis.FlowAnalysis.Worklist`1._queue"/>./
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.TypeRefFactory.CreateTypeRefContext(Pchp.CodeAnalysis.Symbols.SourceTypeSymbol)">
            <summary>
            Creates type context for a method within given type, determines naming, type context.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.PhpSyntaxTree">
            <summary>
            Adapter providing <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> from <see cref="T:Devsense.PHP.Syntax.SourceUnit"/> and storing parse diagnostics.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.Lambdas">
            <summary>
            Gets constructed lambda nodes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.Types">
            <summary>
            Gets constructed type declaration nodes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.Functions">
            <summary>
            Gets constructed function declaration nodes.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.Root">
            <summary>
            Gets constructed global code (ast root).
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.YieldNodes">
            <summary>
            Gets constructed yield extpressions.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.PharStubFile">
            <summary>In case of Phar entry, gets or set the PHAR stub.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.IsPharEntry">
            <summary>
            Gets value indicating the file is a PHAR entry.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.PhpSyntaxTree.IsPharStub">
            <summary>
            Whether the code is a phar stub.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.PhpSyntaxTree.GetDebugSourceDocumentPath">
            <summary>
            Gets file path for the debug document and embedded text feature.
            In most cases it is equivalent to <see cref="P:Pchp.CodeAnalysis.PhpSyntaxTree.FilePath"/>,
            in synthesized stubs (phar stub) it may be a generated file name.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.PhpSyntaxTree.s_langversions">
            <summary>
            Map of supported language versions and corresponding <see cref="T:Devsense.PHP.Syntax.LanguageFeatures"/> understood by underlying parser.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.PatchItemUse(Devsense.PHP.Syntax.Ast.ItemUse)">
            <summary>
            Fixes <see cref="T:Devsense.PHP.Syntax.Ast.ItemUse"/> so it propagates correctly through our visitor.
            </summary>
            <remarks><c>IsMemberOf</c> will be set on Array, not ItemUse itself.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.WithTokenText(Devsense.PHP.Syntax.CompleteToken,System.String)">
            <summary>
            Creates new struct with updated <see cref="F:Devsense.PHP.Syntax.CompleteToken.TokenText"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.WithToken(Devsense.PHP.Syntax.CompleteToken,Devsense.PHP.Syntax.Tokens)">
            <summary>
            Creates new struct with updated <see cref="F:Devsense.PHP.Syntax.CompleteToken.TokenText"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.IsWhitespace(Devsense.PHP.Syntax.CompleteToken)">
            <summary>
            Gets value indicating the token is an ignored token - whitespace or comment.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.HasThisVariable(Devsense.PHP.Syntax.Ast.MethodDecl)">
            <summary>
            Determines whether method has <c>$this</c> variable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.LinePosition(Devsense.PHP.Text.ILineBreaks,System.Int32)">
            <summary>
            Gets <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> from source position.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.IsIgnoredEntry(Devsense.PHP.Phar.Entry)">
            <summary>
            Gets value indicating this entry will be skipped.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.IsCompileEntry(Devsense.PHP.Phar.Entry)">
            <summary>
            Determines whether to treat given PHAR entry as a PHP source file (whether to compile it).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetOffset(Pchp.CodeAnalysis.PhpSyntaxTree,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Returns the offset of the location specified by (zero-based) line and character from the start of the file.
            In the case of invalid line, -1 is returned.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.AstUtils.AppStaticTagName">
            <summary>
            Attribute name determining the field below is app-static instead of context-static.
            @appstatic
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.AstUtils.DeprecatedTagName">
            <summary>
            @deprecated
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.IsAppStatic(Devsense.PHP.Syntax.Ast.FieldDeclList)">
            <summary>
            Lookups notation determining given field as app-static instead of context-static.
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.ToTextSpan(Devsense.PHP.Text.Span)">
            <summary>
            Wraps given <see cref="T:Devsense.PHP.Text.Span"/> into <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> representing the same value.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetTextSpan(Pchp.CodeAnalysis.Semantics.BoundExpression)">
            <summary>
            Gets text span of given expression.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetAnonymousTypeName(Devsense.PHP.Syntax.Ast.AnonymousTypeDecl)">
            <summary>
            CLR compliant anonymous class name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetAnonymousTypeQualifiedName(Devsense.PHP.Syntax.Ast.AnonymousTypeDecl)">
            <summary>
            Builds qualified name for an anonymous PHP class.
            Instead of name provided by parser, we do create our own which is more readable and shorter.
            </summary>
            <remarks>Wherever <see cref="P:Devsense.PHP.Syntax.Ast.AnonymousTypeDecl.QualifiedName"/> would be used, use this method instead.</remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.FindParentLangElement``1(Devsense.PHP.Syntax.Ast.ILangElement)">
            <summary>
            Traverses AST and finds closest parent element of desired type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetContainingRoutine(Devsense.PHP.Syntax.Ast.ILangElement)">
            <summary>
            Gets containing routine element (function, method or lambda).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.GetMoveNextSpan(Devsense.PHP.Syntax.Ast.ForeachStmt)">
            <summary>
            Gets the span of "as" keyword in between enumeree and variables.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.SelectElements``1(Devsense.PHP.Syntax.Ast.LangElement,System.Func{Devsense.PHP.Syntax.Ast.ILangElement,System.Boolean})">
            <summary>
            Gets all elements of given type.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.AstUtils.SelectLocalVariables(Devsense.PHP.Syntax.Ast.LangElement)">
            <summary>
            Gets all occurences of <see cref="T:Devsense.PHP.Syntax.Ast.DirectVarUse"/> in given scope.
            Ignores autoglobals and $this.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Utilities.CompilationTrackerExtension.TimeSpanMetric">
            <summary>
            Helper value to remember the start time of time span metric.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Utilities.DistinctQueue`1">
            <summary>
            Represents priority queue where items are enqueued just once and queue can be accessed in parallel.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Utilities.DistinctQueue`1._set">
            <summary>
            A set to mark already inserted objects.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.Utilities.DistinctQueue`1._queue">
            <summary>
            A heap to enable fast insertion and minimum extraction.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Utilities.DistinctQueue`1.Count">
            <summary>
            Count of items in the queue.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.DistinctQueue`1.Contains(`0)">
            <summary>
            Gets value indicating 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.DistinctQueue`1.Enqueue(`0)">
            <summary>
            Enqueues item into the queue.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.DistinctQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues item from the queue.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.Utilities.MemberQualifiedName">
            <summary>
            Name of a member (method, property, field) within a type.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Utilities.MemberQualifiedName.TypeName">
            <summary>
            Containing type name.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.Utilities.MemberQualifiedName.MemberName">
            <summary>
            The member name.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.PhpFileUtilities.NormalizeSlashes(System.String)">
            <summary>
            Normalizes backward slashes to forward slashes.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.PhpFileUtilities.IsPharFile(System.String)">
            <summary>
            Gets value indicating whether the file should be treated as a PHAR file archive.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Utilities.PhpFileUtilities.BuildPharStubFileName(System.String)">
            <summary>
            Virtual file name corresponding to the phar file stub.
            Gets embedded into PDB so it can be debugged.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.ToConstantValueOrNull(Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Tries to convert <paramref name="value"/> to a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/> if possible.
            Argument that doesn't have value or values which cannot be represented as <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/> causes a <c>null</c> reference to be returned.
            </summary>
            <param name="value">Optional boced value.</param>
            <returns><see cref="T:Microsoft.CodeAnalysis.ConstantValue"/> instance if possible. Otherwise a <c>null</c> reference.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.IsNull(Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Gets value indicating the constant value is set and its value is <c>null</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.IsZero(Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Gets value indicating the given constant is number zero.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.EqualsOptional(Microsoft.CodeAnalysis.Optional{System.Object},Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Determines whether the specified optional value is equal to the current one.
            If <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> of both is set to false, they are considered equal.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.TryConvertToLong(Microsoft.CodeAnalysis.ConstantValue,System.Int64@)">
            <summary>
            PHP safe implicit conversion to <c>long</c> (null|long|double to long).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.TryConvertToBool(Microsoft.CodeAnalysis.Optional{System.Object},System.Boolean@)">
            <summary>
            PHP safe implicit conversion to <c>bool</c> if the value is known.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.TryConvertToLong(Microsoft.CodeAnalysis.Optional{System.Object},System.Int64@)">
            <summary>
            PHP safe implicit conversion to <c>long</c> if the value is known.
            </summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.ConstantValueExtensions.s_true">
            <summary>Boxed <c>boolean</c> to be re-used.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.ConstantValueExtensions.s_false">
            <summary>Boxed <c>boolean</c> to be re-used.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.AsObject(System.Boolean)">
            <summary>
            Boxes <see cref="T:System.Boolean"/> into object without memory allocation.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.AsObject(System.Int32)">
            <summary>
            Boxes <see cref="T:System.Int32"/> into object, avoids alloc if possible.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.AsObject(System.Int64)">
            <summary>
            Boxes <see cref="T:System.Int64"/> into object, avoids alloc if possible.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.AsOptional(System.Boolean)">
            <summary>
            Gets <see cref="T:Microsoft.CodeAnalysis.Optional`1"/> of <see cref="T:System.Boolean"/>.
            This method does not allocate a new boolean on heap.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.AsOptional(System.Int64)">
            <summary>
            Gets <see cref="T:Microsoft.CodeAnalysis.Optional`1"/> of <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.IsBool(Microsoft.CodeAnalysis.Optional{System.Object},System.Boolean@)">
            <summary>
            Checks if <paramref name="optional"/> contains a boolean value. If so, it retrieves it in
            <paramref name="value"/> and return TRUE. Otherwise, returns FALSE.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.ConstantValueExtensions.IsInteger(Microsoft.CodeAnalysis.Optional{System.Object},System.Int64@)">
            <summary>
            Checks if <paramref name="optional"/> contains a long or int value. If so, it retrieves it as long
            (possibly converting from int) in <paramref name="value"/> and returns TRUE. Otherwise, returns FALSE.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Contract.ThrowIfNull``1(``0)">
            <summary>
            Throws <see cref="T:System.ArgumentNullException"/> if given value is <c>null</c>.
            </summary>
            <typeparam name="T">Value type. Must be a reference type.</typeparam>
            <param name="value">Argument value.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Contract.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws <see cref="T:System.ArgumentNullException"/> if given value is <c>null</c>.
            </summary>
            <typeparam name="T">Value type. Must be a reference type.</typeparam>
            <param name="value">Argument value.</param>
            <param name="message">Error message.</param>
        </member>
        <member name="M:Pchp.CodeAnalysis.Contract.ThrowIfNull``1(``0,System.String,System.String)">
            <summary>Throws <see cref="T:System.ArgumentNullException"/> if given value is <c>null</c>.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.Contract.ThrowIfNull``1(``0,System.String,System.String,System.String)">
            <summary>Throws <see cref="T:System.ArgumentNullException"/> if given value is <c>null</c>.</summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.TryGetOrDefault``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            Gets value from given dictionary corresponding to the key if the key is contained, otherwise default of <typeparamref name="T"/>.
            </summary>
            <typeparam name="K">Key type.</typeparam>
            <typeparam name="T">Value type.</typeparam>
            <param name="dict">Dictionary. Cannot be null.</param>
            <param name="key">Key.</param>
            <returns>Value corresponding to key or default of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.TryGetOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets value from given dictionary corresponding to the key if the key is contained, otherwise default of <typeparamref name="T"/>.
            </summary>
            <typeparam name="K">Key type.</typeparam>
            <typeparam name="T">Value type.</typeparam>
            <param name="dict">Dictionary. Cannot be null.</param>
            <param name="key">Key.</param>
            <returns>Value corresponding to key or default of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Calls given action for each element in given enumerable.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.ForEach``1(``0[],System.Action{``0})">
            <summary>
            Calls given action for each element in given array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.ForEach``1(``0[],System.Action{System.Int32,``0})">
            <summary>
            Calls given action for each element in given array.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.MergeArrays``1(``0[],``0[],System.Func{``0,``0,``0})">
            <summary>
            Mixes two array of the same length into new one, using <paramref name="mixer"/> function applied on each pair of elements from first and second arrays.
            </summary>
            <typeparam name="T">Elements type.</typeparam>
            <param name="arr1">First array.</param>
            <param name="arr2">Second array.</param>
            <param name="mixer">Mixing function.</param>
            <returns>Mixed array.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.EqualEntries``1(``0[],``0[])">
            <summary>
            Checks entries in given arrays for equality.
            If arrays are of a different size, default(T) is used for comparison.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.IndexOf``1(System.Collections.Immutable.ImmutableArray{``0},System.Predicate{``0})">
            <summary>
            Finds index of first element passing given predicate.
            Returns <c>-1</c> if not found.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.EnumeratorExtension.AsImmutableSafe``1(System.Collections.Generic.IList{``0})">
            <summary>
            Converts list to <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> safely. If the list is <c>null</c>, empty array is returned.
            </summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.ConditionalList`1">
            <summary>
            <see cref="T:System.Collections.Generic.IList`1"/> implementation where only allowed items are actually added.
            </summary>
            <typeparam name="T">Item type.</typeparam>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.MakeQualifiedName(Devsense.PHP.Syntax.Name,Devsense.PHP.Syntax.Ast.NamespaceDecl)">
            <summary>
            Combines name and its namespace.
            </summary>
            <param name="name">Name.</param>
            <param name="ns">Can be <c>null</c>.</param>
            <returns></returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.MakeQualifiedName(Devsense.PHP.Syntax.Ast.TypeDecl)">
            <summary>
            Gets full qualified name of the type declaration.
            </summary>
            <param name="type">Type, cannot be <c>null</c>.</param>
            <returns>Qualified name of the type.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.MakeQualifiedName(System.String,System.Boolean)">
            <summary>
            Make QualifiedName from the string like AAA\BBB\XXX
            </summary>
            <returns>Qualified name.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.GetNamingContext(Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol)">
            <summary>
            Create naming context.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.GetNamingContext(Devsense.PHP.Syntax.Ast.NamespaceDecl,Devsense.PHP.Syntax.SourceUnit)">
            <summary>
            Create naming context.
            </summary>
            <param name="ns">Current namespace declaration. In case it is <c>null</c>, context for global code is created.</param>
            <param name="unit">Global code used when <paramref name="ns"/> is <c>null</c>.</param>
            <returns>Naming context. Cannot be <c>null</c>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.GetNamingContext(Devsense.PHP.Syntax.Ast.TypeDecl)">
            <summary>
            Create naming context in context of given type declaration.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.ClrName(Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Gets CLR name using dot as a name separator.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.GetFullName(Pchp.CodeAnalysis.Symbols.NamedTypeSymbol)">
            <summary>
            Gets full CLR name including the namespace part.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.NamesEquals(Devsense.PHP.Syntax.Name[],Devsense.PHP.Syntax.Name[])">
            <summary>
            Compares two arrays.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.NameEquals(Devsense.PHP.Syntax.QualifiedName,Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Compares two qualified names.
            </summary>
            <remarks>
            The original comparison operator on <see cref="T:Devsense.PHP.Syntax.QualifiedName"/> fails when any of the comparands is not initialized.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.NameEquals(Devsense.PHP.Syntax.VariableName,Devsense.PHP.Syntax.VariableName)">
            <summary>
            Compares two variable names.
            </summary>
            <remarks>
            The original comparison operator on <see cref="T:Devsense.PHP.Syntax.QualifiedName"/> fails when any of the comparands is not initialized.
            </remarks>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.IsEmpty(Devsense.PHP.Syntax.QualifiedName)">
            <summary>
            Gets value indicating whether given qualified name was not set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.IsEmpty(Devsense.PHP.Syntax.VariableName)">
            <summary>
            Gets value indicating whether given name was not set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.IsValid(Devsense.PHP.Syntax.VariableName)">
            <summary>
            Gets value indicating whether given name was not set.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.AsVarName(System.String)">
            <summary>
            Gets variable name without leading <c>$</c>.
            </summary>
            <param name="varname">String in form of <c>$varname</c> or <c>$GLOBALS['varname']</c> or <c>'varname'</c></param>
            <returns>Variable name without leading <c>$</c> or <c>null</c>.</returns>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.IsGlobalVar(Devsense.PHP.Syntax.Ast.ItemUse)">
            <summary>
            Gets value indicating whether the expression is in form of <c>$GLOBALS[...]</c>.
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.TryGetGlobalVarName(Devsense.PHP.Syntax.Ast.ItemUse,Devsense.PHP.Syntax.VariableName@)">
            <summary>
            Tries to resolve global variable name from array item use. (eg. <c>$GLOBALS["varname"]</c>).
            </summary>
        </member>
        <member name="M:Pchp.CodeAnalysis.NameUtils.IsGetArgsOrArgsNumFunctionName(Devsense.PHP.Syntax.TranslatedQualifiedName)">
            <summary>Gets <c>true</c> if name corresponds to func_num_args, func_get_arg, func_get_args.</summary>
        </member>
        <member name="T:Pchp.CodeAnalysis.NameUtils.SpecialNames">
            <summary>
            Special PHP type and function names.
            </summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.shell_exec">
            <summary>Special <c>shell_exec</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.is_null">
            <summary>Special <c>is_null</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.assert">
            <summary>Special <c>assert</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.dirname">
            <summary>Special <c>dirname</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.basename">
            <summary>Special <c>basename</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.get_parent_class">
            <summary><c>get_parent_class</c> function name.</summary>
        </member>
        <member name="P:Pchp.CodeAnalysis.NameUtils.SpecialNames.method_exists">
            <summary><c>method_exists</c> function name.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.NameUtils.SpecialNames.define">
            <summary><c>define</c> function name.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.NameUtils.SpecialNames.defined">
            <summary><c>defined</c> function name.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.NameUtils.SpecialNames.constant">
            <summary><c>constant</c> function name.</summary>
        </member>
        <member name="F:Pchp.CodeAnalysis.NameUtils.SpecialNames.ord">
            <summary><c>ord</c> function name.</summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Errors.ErrorStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.AutoloadDeprecatedMessage">
            <summary>
              Looks up a localized string similar to Use spl_autoload_register() instead..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ArgumentTypeMismatch">
            <summary>
              Looks up a localized string similar to Argument {0} passed to {1}() must be of the type {2}, {3} given.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BadAssemblyName">
            <summary>
              Looks up a localized string similar to Invalid assembly name: {0}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BadCompilationOptionValue">
            <summary>
              Looks up a localized string similar to Invalid &apos;{0}&apos; value: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BadDocumentationMode">
            <summary>
              Looks up a localized string similar to Provided documentation mode is unsupported or invalid: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BadSourceCodeKind">
            <summary>
              Looks up a localized string similar to Provided source code kind is unsupported or invalid: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BadSwitch">
            <summary>
              Looks up a localized string similar to Unrecognized option: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_BinaryFile">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a binary file instead of a text file.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotAssignToThis">
            <summary>
              Looks up a localized string similar to Cannot re-assign $this.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotDeclareReturnType">
            <summary>
              Looks up a localized string similar to {0}() cannot declare a return type.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotEmbedWithoutPdb">
            <summary>
              Looks up a localized string similar to /embed switch is only supported when emitting Portable PDB (/debug:portable or /debug:embedded)..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotExtendFrom">
            <summary>
              Looks up a localized string similar to Class {0} cannot extend from {1} {2}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotImplementNonInterface">
            <summary>
              Looks up a localized string similar to {0} cannot implement {1} - it is not an interface.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotInstantiateType">
            <summary>
              Looks up a localized string similar to Cannot instantiate {0} {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CannotUseNonTrait">
            <summary>
              Looks up a localized string similar to {0} cannot use {1} - it is not a trait.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CantOpenFileWrite">
            <summary>
              Looks up a localized string similar to Cannot open &apos;{0}&apos; for writing -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CantReadResource">
            <summary>
              Looks up a localized string similar to Error reading resource &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CircularBase">
            <summary>
              Looks up a localized string similar to Circular base class dependency involving &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CompileCancelled">
            <summary>
              Looks up a localized string similar to Compilation cancelled by user.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CtorPropertyAbstractCtor">
            <summary>
              Looks up a localized string similar to Cannot declare promoted property in an abstract constructor.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CtorPropertyNotCtor">
            <summary>
              Looks up a localized string similar to Cannot declare promoted property outside a constructor.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CtorPropertyStaticCtor">
            <summary>
              Looks up a localized string similar to Cannot declare promoted property in a static constructor.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_CtorPropertyVariadic">
            <summary>
              Looks up a localized string similar to Cannot declare variadic promoted property.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_DefaultParameterValueTypeMismatch">
            <summary>
              Looks up a localized string similar to Default value for parameter ${0} with a {1} type can only be {1} or NULL, {2} type given.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_EncodinglessSyntaxTree">
            <summary>
              Looks up a localized string similar to Cannot emit debug information for a source text without encoding..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_EncUpdateFailedMissingAttribute">
            <summary>
              Looks up a localized string similar to Cannot update &apos;{0}&apos;; attribute &apos;{1}&apos; is missing..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ErrorOpeningAssemblyFile">
            <summary>
              Looks up a localized string similar to Error opening assembly file &apos;{0}&apos;: {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_FileNotFound">
            <summary>
              Looks up a localized string similar to Source file &apos;{0}&apos; could not be found..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_FinalAbstractClassDeclared">
            <summary>
              Looks up a localized string similar to Cannot use the final modifier on an abstract class.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_InvalidConstantExpression">
            <summary>
              Looks up a localized string similar to Constant expression contains invalid operations.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_InvalidDebugInfo">
            <summary>
              Looks up a localized string similar to Unable to read debug information of method &apos;{0}&apos; (token 0x{1:X8}) from assembly &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_InvalidFunctionName">
            <summary>
              Looks up a localized string similar to Function name must be a string, {0} given.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_InvalidHashAlgorithmName">
            <summary>
              Looks up a localized string similar to Invalid hash algorithm name: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_InvalidInstrumentationKind">
            <summary>
              Looks up a localized string similar to Invalid instrumentation kind: {0}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_MetadataFileNotFound">
            <summary>
              Looks up a localized string similar to Metadata file &apos;{0}&apos; could not be found.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_MethodCalledOnNonObject">
            <summary>
              Looks up a localized string similar to Call to a member function {0}() on {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ModuleEmitFailure">
            <summary>
              Looks up a localized string similar to Failed to emit module &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_MultipleAnalyzerConfigsInSameDir">
            <summary>
              Looks up a localized string similar to Multiple analyzer config files cannot be in the same directory (&apos;{0}&apos;)..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_MustTakeArgs">
            <summary>
              Looks up a localized string similar to {0} {1}() must take exactly {2} arguments.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_MutuallyExclusiveOptions">
            <summary>
              Looks up a localized string similar to Compilation options &apos;{0}&apos; and &apos;{1}&apos; can&apos;t both be specified at the same time..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_NeedsLoopOrSwitch">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; not in the &apos;loop&apos; or &apos;switch&apos; context.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_NeverReturningFunctionCannotReturn">
            <summary>
              Looks up a localized string similar to A never-returning function cannot return.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_NoMatchingOverload">
            <summary>
              Looks up a localized string similar to No overload for method {0} can be called..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_NoSourceFile">
            <summary>
              Looks up a localized string similar to Source file &apos;{0}&apos; could not be opened -- {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_NotYetImplemented">
            <summary>
              Looks up a localized string similar to {0} is currently not supported by PeachPie..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_OptionMustBeAbsolutePath">
            <summary>
              Looks up a localized string similar to Option &apos;{0}&apos; must be an absolute path..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_OutputWriteFailed">
            <summary>
              Looks up a localized string similar to Could not write to output file &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ParameterTypeNotAllowed">
            <summary>
              Looks up a localized string similar to Parameter ${0} cannot have type {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PdbWritingFailed">
            <summary>
              Looks up a localized string similar to Failure writing debug information: {0}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PeWritingFailure">
            <summary>
              Looks up a localized string similar to An error occurred while writing the output file: {0}..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PositionalArgAfterUnpacking">
            <summary>
              Looks up a localized string similar to Cannot use positional argument after argument unpacking.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PrimitiveTypeNameMisused">
            <summary>
              Looks up a localized string similar to Use of primitive type &apos;{0}&apos; is misused.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PropertyAccessibilityError">
            <summary>
              Looks up a localized string similar to Access level to {0}::${1} must be {2} (as in class {3}) or weaker.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_PropertyTypeNotAllowed">
            <summary>
              Looks up a localized string similar to Property {0}::${1} cannot have type {2}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ReadOnlyPropertyWritten">
            <summary>
              Looks up a localized string similar to Cannot set read-only property {0}::${1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ResourceNotUnique">
            <summary>
              Looks up a localized string similar to Resource identifier &apos;{0}&apos; has already been used in this assembly.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_StartupObjectNotFound">
            <summary>
              Looks up a localized string similar to Startup object matching &apos;{0}&apos; could not be resolved.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_SwitchNeedsValue">
            <summary>
              Looks up a localized string similar to Missing value for &apos;{0}&apos; option.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ThisOutOfObjectContext">
            <summary>
              Looks up a localized string similar to Using $this when not in object context.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_TooManyUserStrings">
            <summary>
              Looks up a localized string similar to Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_TypeMismatch">
            <summary>
              Looks up a localized string similar to Cannot convert {0} to {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_TypeNameCannotBeResolved">
            <summary>
              Looks up a localized string similar to Type name &apos;{0}&apos; could not be resolved..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_UnknownTypeDependencies">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; cannot be declared..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_ValueOfTypeCannotBeAliased">
            <summary>
              Looks up a localized string similar to Value of type &apos;{0}&apos; cannot be passed by reference.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_VariadicParameterNotLast">
            <summary>
              Looks up a localized string similar to Only the last parameter can be variadic.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.ERR_VoidFunctionCannotReturnValue">
            <summary>
              Looks up a localized string similar to A void function must not return a value.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.FTL_BadCodepage">
            <summary>
              Looks up a localized string similar to Code page &apos;{0}&apos; is invalid or not installed.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.FTL_InvalidInputFileName">
            <summary>
              Looks up a localized string similar to File name &apos;{0}&apos; is empty, contains invalid characters, has a drive specification without an absolute path, or is too long.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_ConstantAlreadyDefined">
            <summary>
              Looks up a localized string similar to Constant &apos;{0}&apos; with the same name is already defined.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_DestructDiscouraged">
            <summary>
              Looks up a localized string similar to Use of &apos;__destruct&apos; is discouraged. Garbage collection behavior is a subject to change..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_EvalDiscouraged">
            <summary>
              Looks up a localized string similar to Use of &apos;eval()&apos; is discouraged. Construct allows execution of arbitrary code and is subject to performance and memory overhead..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_OverrideNameCaseMismatch">
            <summary>
              Looks up a localized string similar to Overriden function name &apos;{0}&apos; does not match it&apos;s parent name &apos;{1}&apos;, letter casing mismatch..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_RedundantCast">
            <summary>
              Looks up a localized string similar to Cast is redundant..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.INF_TypeNameCaseMismatch">
            <summary>
              Looks up a localized string similar to Name &apos;{0}&apos; does not match the expected name &apos;{1}&apos;, letter casing mismatch..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_AmbiguousDeclaration">
            <summary>
              Looks up a localized string similar to The declaration of &apos;{0}&apos; is ambiguous resulting in multiple versions to be compiled. Fix this issue by ensuring every base type is declared just once unconditionally..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ArgumentVoid">
            <summary>
              Looks up a localized string similar to Argument has no value, parameter will be always NULL.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_AssertAlwaysFail">
            <summary>
              Looks up a localized string similar to Assertion will always fail.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_AssigningSameVariable">
            <summary>
              Looks up a localized string similar to Assignment made to same variable; did you mean to assign something else?.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_AttributeBindError">
            <summary>
              Looks up a localized string similar to Couldn&apos;t bind attribute &apos;{0}&apos;. Either its arguments don&apos;t match any constructor or the type don&apos;t extend &apos;Attribute&apos; class..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_CalledFromGlobalScope">
            <summary>
              Looks up a localized string similar to Called from the global scope.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_CannotIncludeFile">
            <summary>
              Looks up a localized string similar to Script file &apos;{0}&apos; could not be resolved, the script inclusion is unbound..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_CloneNonObject">
            <summary>
              Looks up a localized string similar to Cloning of non-object: {0}..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_DuplicateArrayKey">
            <summary>
              Looks up a localized string similar to Duplicate array key: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ExpressionNotRead">
            <summary>
              Looks up a localized string similar to The expression is not being read. Did you mean to assign it somewhere?.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_FieldPhpDocAssignIncompatible">
            <summary>
              Looks up a localized string similar to Value of type {0} assigned to field {1} is incompatible with its PHPDoc type {2}..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ForeachNonIterable">
            <summary>
              Looks up a localized string similar to Using non-iterable type in foreach: {0}..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_FormatStringWrongArgCount">
            <summary>
              Looks up a localized string similar to Call to &apos;{0}()&apos; expects {1} argument(s), {2} given..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_GeneratorFailedDuringGeneration">
            <summary>
              Looks up a localized string similar to Generator &apos;{0}&apos; failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type &apos;{1}&apos; with message &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_GeneratorFailedDuringInitialization">
            <summary>
              Looks up a localized string similar to Generator &apos;{0}&apos; failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type &apos;{1}&apos; with message &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_InvalidArrayKeyType">
            <summary>
              Looks up a localized string similar to Invalid array key type: {0}..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_MissingArguments">
            <summary>
              Looks up a localized string similar to {0}() expects at least {1} parameter(s), {2} given.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_NoSourceFiles">
            <summary>
              Looks up a localized string similar to No source files specified.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_NotYetImplementedIgnored">
            <summary>
              Looks up a localized string similar to {0} will be ignored, because it is currently not supported by Peachpie..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ParamPhpDocTypeHintIncompatible">
            <summary>
              Looks up a localized string similar to PHPDoc type &apos;{0}&apos; of parameter ${1} is incompatible with its type hint &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ParentCtorNotCalled">
            <summary>
              Looks up a localized string similar to Missing the call of parent::__construct from {0}::__construct..
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_PCRE_Pattern_Error">
            <summary>
              Looks up a localized string similar to PCRE pattern parse error: {0} at offset {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_StringAssertionDeprecated">
            <summary>
              Looks up a localized string similar to Using string as the assertion is deprecated.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_SymbolDeprecated">
            <summary>
              Looks up a localized string similar to Deprecated: {0} &apos;{1}&apos; has been deprecated. {2}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_TooManyArguments">
            <summary>
              Looks up a localized string similar to {0}() expects {1} parameter(s), {2} given.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_ToStringMustReturnString">
            <summary>
              Looks up a localized string similar to Method {0}::__toString() must return a string value.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_TypeNameInUse">
            <summary>
              Looks up a localized string similar to {0} &apos;{1}&apos; is already defined.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_UndefinedFunctionCall">
            <summary>
              Looks up a localized string similar to Call to undefined function: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_UndefinedMethodCall">
            <summary>
              Looks up a localized string similar to Call to undefined method: {0}::{1}().
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_UndefinedType">
            <summary>
              Looks up a localized string similar to Class &apos;{0}&apos; not found.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_UninitializedVariableUse">
            <summary>
              Looks up a localized string similar to Undefined variable: ${0}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Errors.ErrorStrings.WRN_UnreachableCode">
            <summary>
              Looks up a localized string similar to Unreachable code detected.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.FlowAnalysis.Graph.CallGraph">
            <summary>
            Stores the information about the calls among the routines in source code. This class is thread-safe.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.FlowAnalysis.Graph.CallGraph._incidentEdges">
            <summary>
            Maps each node to its incident edges, their directions can be found by <see cref="P:Peachpie.CodeAnalysis.FlowAnalysis.Graph.CallGraph.Edge.Caller"/>
            and <see cref="P:Peachpie.CodeAnalysis.FlowAnalysis.Graph.CallGraph.Edge.Callee"/>.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.PhpResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.IDS_Donate">
            <summary>
              Looks up a localized string similar to Donate to support the development of PeachPie! https://bit.ly/3pfXw2q.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Peachpie.CodeAnalysis.PhpResources.IDS_Help" -->
        <member name="P:Peachpie.CodeAnalysis.PhpResources.IDS_LangVersions">
            <summary>
              Looks up a localized string similar to Language versions:.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.IDS_Logo">
            <summary>
              Looks up a localized string similar to {0} version {1}.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.IDS_ToolName">
            <summary>
              Looks up a localized string similar to PeachPie PHP Compiler.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.PhpResources.XmlDoc_FieldsOnlyCtor">
            <summary>
              Looks up a localized string similar to Initializes the class without calling its &apos;__construct&apos; method..
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsNullable(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Gets value indicating the type refers to a nullable type (<c>?TYPE</c>).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsNullClass(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Whether the type refers to a special "null" class name, valid only within a union.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsMixed(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Gets value indicating the type refers to a mixed type (<c>mixed</c>).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsNever(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Gets value indicating the type refers to a mixed type (<c>mixed</c>).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsVoid(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Gets value indicating the type refers to "void" type (<c>void</c>).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.IsCallable(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            Gets value indicating the type refers to <c>callable</c> or <c>?callable</c>.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Semantics.TypeRefExtension.CanBeNull(Devsense.PHP.Syntax.Ast.TypeRef)">
            <summary>
            determines whether given type can represent a NULL type.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Symbols.AttributeHelpers.HasDefaultValueAttributeData(System.Reflection.Metadata.EntityHandle,Pchp.CodeAnalysis.Symbols.PEModuleSymbol)">
            <summary>
            Looks for <c>Peachpie.Runtime</c>'s <c>DefaultValueAttribute</c>.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec">
            <summary>
            Value to be imported.
            From `Pchp.Core.ImportValueAttribute+ValueSpec`.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.CallerClass">
            <summary>
            Current class context.
            The parameter must be of type <see cref="T:System.RuntimeTypeHandle"/>, <c>PhpTypeInfo</c> or <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.CallerStaticClass">
            <summary>
            Current late static bound class (<c>static</c>).
            The parameter must be of type <c>PhpTypeInfo</c>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.This">
            <summary>
            Calue of <c>$this</c> variable or <c>null</c> if variable is not defined.
            The parameter must be of type <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.Locals">
            <summary>
            Provides a reference to the array of local PHP variables.
            The parameter must be of type <c>PhpArray</c>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.CallerArgs">
            <summary>
            Provides callers parameters.
            The parameter must be of type array of <c>PhpValue</c>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.CallerScript">
            <summary>
            Provides reference to the current script container.
            The parameter must be of type <see cref="T:System.RuntimeTypeHandle"/>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Symbols.ImportValueAttributeData.ValueSpec.LocalVariable">
            <summary>
            Provides reference to local variable with same name as the parameter name.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Symbols.ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(Microsoft.CodeAnalysis.ObsoleteAttributeData@,System.Reflection.Metadata.EntityHandle,Pchp.CodeAnalysis.Symbols.PEModuleSymbol,System.Boolean)">
            <summary>
            Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Symbols.ObsoleteAttributeHelpers.GetObsoleteDataFromMetadata(System.Reflection.Metadata.EntityHandle,Pchp.CodeAnalysis.Symbols.PEModuleSymbol,System.Boolean)">
            <summary>
            Get the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider">
            <summary>
            Tokens provider that matches additional syntax patterns,
            stores them in <see cref="T:Peachpie.CodeAnalysis.Syntax.NodesFactory"/> and
            does not pass used tokens to the <see cref="M:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider.GetNextToken"/>.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider._typeRefFactory">
            <summary>
            Factory for <see cref="T:Devsense.PHP.Syntax.Ast.TypeRef"/>, translates given qualified name using current naming context.
            Arguments: (<see cref="T:Devsense.PHP.Syntax.QualifiedNameRef"/> typeName, <see cref="T:System.Boolean"/> allowPrimitiveTypeNames).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider.MatchToken(System.Int32@,Devsense.PHP.Syntax.Tokens)">
            <summary>
            Matches token at position and advances the position to next token.
            If token does not match, function return <c>false</c> and position is not advanced.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider.MatchToken(System.Int32@,Devsense.PHP.Syntax.Tokens,Devsense.PHP.Syntax.CompleteToken@,System.Boolean)">
            <summary>
            Matches token at position and advances the position to next token.
            If token does not match, function return <c>false</c> and position is not advanced.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.AdditionalSyntaxProvider.MatchGenericTypes(System.Int32@,System.Collections.Generic.List{Devsense.PHP.Syntax.Ast.TypeRef}@)">
            <summary>
            Matches "&lt;T1,T2&gt;".
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Syntax.NodesFactory">
            <summary>
            Provides nodes instantiation for underlaying parser
            and collects instantiated nodes.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Syntax.NodesFactory.Lambdas">
            <summary>
            Gets constructed lambda nodes.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Syntax.NodesFactory.Types">
            <summary>
            Gets constructed type declaration nodes.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Syntax.NodesFactory.Functions">
            <summary>
            Gets constructed function declaration nodes.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Syntax.NodesFactory.Root">
            <summary>
            Gets constructed global code (ast root).
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Syntax.NodesFactory.YieldNodes">
            <summary>
            Gets constructed yield extpressions.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.NodesFactory.AddAndReturn``1(System.Collections.Generic.List{``0}@,``0)">
            <summary>
            Adds node to the list and returns the node.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.NodesFactory.TryGetAnotation``1(System.Int32,``0@)">
            <summary>
            Gets an additional annotation if any.
            </summary>
            <typeparam name="T">Annotation type.</typeparam>
            <param name="position">Position of the annotation.</param>
            <param name="obj">Resulting object.</param>
            <returns>Wtehher the annotation was found.</returns>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Syntax.PhpSyntaxReference">
            <summary>
            this is a basic do-nothing implementation of a syntax reference
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Syntax.PhpTokenProvider">
            <summary>
            Wrapping token provider that buffers and allows for token lookup.
            </summary>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Syntax.PhpTokenProvider._buffer">
            <summary>
            Buffered tokens.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.PhpTokenProvider.Lookup(System.Int32)">
            <summary>
            Gets token information.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Syntax.PhpTokenProvider.Remove(System.Int32,System.Int32)">
            <summary>
            Replaces range of tokens with whitespace.
            We need to keep the spans of whitespaces for PHPDoc resolution.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Utilities.BitMask64">
            <summary>
            A general structure to record bit information about indexed entities in flow analysis.
            </summary>
            <remarks>
            The minimum and initial lattice element is 0, the maximum is ~0. Indices outside the scope of ulong (64)
            are regarded as present in the set.
            </remarks>
        </member>
        <member name="F:Peachpie.CodeAnalysis.Utilities.BitMask64.BitsCount">
            <summary>
            Size of ulong bit array (<c>64</c>).
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Utilities.VoidStruct">
            <summary>
            Empty structure to be used in generic classes requiring return or argument type (such as <see cref="T:Pchp.CodeAnalysis.Semantics.PhpOperationVisitor`1"/>).
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.ExceptionUtilities.GuessSourceLocation(Microsoft.CodeAnalysis.CodeGen.ILBuilder,Pchp.CodeAnalysis.Semantics.IPhpOperation,Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            According to current <see cref="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.SeqPointsOpt"/>, gets file name and position in the source code currently being emitted.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.ExceptionUtilities.NotImplementedException(Pchp.CodeAnalysis.CodeGen.CodeGenerator,System.String,Pchp.CodeAnalysis.Semantics.IPhpOperation)">
            <summary>
            Gets <see cref="T:System.NotImplementedException"/> with aproximate location of the error.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.ExceptionUtilities.NotImplementedException(Microsoft.CodeAnalysis.CodeGen.ILBuilder,System.String,Pchp.CodeAnalysis.Semantics.IPhpOperation,Pchp.CodeAnalysis.Symbols.SourceRoutineSymbol,Pchp.CodeAnalysis.Symbols.MethodSymbol)">
            <summary>
            Gets <see cref="T:System.NotImplementedException"/> with aproximate location of the error.
            </summary>
        </member>
        <member name="T:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1">
            <summary>
            PriorityQueue provides a stack-like interface, except that objects
            "pushed" in arbitrary order are "popped" in order of priority, i.e., 
            from least to greatest as defined by the specified comparer.
            </summary>
            <remarks>
            Push and Pop are each O(log N). Pushing N objects and them popping
            them all is equivalent to performing a heap sort and is O(N log N).
            Multiple different items of the same priority are allowed, but their
            order is not guaranteed to be stable.
            
            The original implementation was taken from the Microsoft .NET
            Framework Reference Source, author: Niklas Borson (niklasb).
            Fixes from https://stackoverflow.com/q/44221454/2105235 were applied.
            </remarks>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.Count">
            <summary>
            Gets the number of items in the priority queue.
            </summary>
        </member>
        <member name="P:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.Top">
            <summary>
            Gets the first or topmost object in the priority queue, which is the
            object with the minimum value.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.Push(`0)">
            <summary>
            Adds an object to the priority queue.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.Pop">
            <summary>
            Removes the first node (i.e., the logical root) from the heap.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.HeapParent(System.Int32)">
            <summary>
            Calculate the parent node index given a child node's index, taking advantage
            of the "shape" property.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.HeapLeftChild(System.Int32)">
            <summary>
            Calculate the left child's index given the parent's index, taking advantage of
            the "shape" property. If there is no left child, the return value is >= _count.
            </summary>
        </member>
        <member name="M:Peachpie.CodeAnalysis.Utilities.PriorityQueue`1.HeapRightFromLeft(System.Int32)">
            <summary>
            Calculate the right child's index from the left child's index, taking advantage
            of the "shape" property (i.e., sibling nodes are always adjacent). If there is
            no right child, the return value >= _count.
            </summary>
        </member>
    </members>
</doc>
